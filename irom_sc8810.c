/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn reset();
void *sub_FFFF0038();
void __fastcall __noreturn die(int, int);
int __fastcall jump_to(int);
void __noreturn irom_enter();
// int *__fastcall _scatterload_copy(int *result, int *, unsigned int);
void sub_FFFF00E8();
void null_1();
void __noreturn sub_FFFF00F4();
void __fastcall __noreturn empty(int, int);
int __fastcall usb_send(_BYTE *, int);
int __fastcall usb_send_reply(unsigned int);
int __fastcall dl_usb_start_data(int a1);
int __fastcall dl_usb_midst_data(int a1);
int dl_usb_exec();
int __fastcall usb_init(int);
signed int arm_clock_config();
int __fastcall usb_endpoint_related(int, int);
int __fastcall sub_FFFF0496(char, char, int, int);
_DWORD *__fastcall sub_FFFF04D0(int a1, int a2);
unsigned int *__fastcall sub_FFFF04FA(int, char, int, __int16);
_DWORD *__fastcall sub_FFFF0524(int, int, int, int, int);
_DWORD *__fastcall sub_FFFF0604(char a1);
int usb_reset_handler();
int usb_enumeration_done();
int sub_FFFF07E8();
signed int maybe_some_usb_interrupts_1();
int __fastcall sub_FFFF09A6(int, int, int);
int __fastcall usb_core_init(int);
int read_uart();
int __fastcall uart_read_for_baudrate(struct UART_REG *a1); // idb
int check_uart_baudrate();
_DWORD *__fastcall uart_setup(_DWORD *result);
uint32 __fastcall uart_trace(unsigned __int8 *, int);
BOOL sub_FFFF0CD8();
unsigned int __fastcall sub_FFFF0D34(int);
SDIO_REG_CFG_TAG *__fastcall sub_FFFF0DA0(int);
SDIO_REG_CFG_TAG *sub_FFFF0E18();
BOOL __fastcall select_mmc_slot(int);
uint32 __fastcall sub_FFFF0F44(int a1);
signed int __fastcall emmc_read_boot0(int a1, volatile uint32 a2);
signed int sub_FFFF1020();
BOOL SPL_Check();
signed int read_spl_from_emmc();
signed int mpll_enable();
signed int chip_pin_init();
signed int timer_enable();
_DWORD *uart_init();
int keypad_init();
int ADI_init();
signed int disable_keypad();
int get_timer_tick();
signed int __fastcall ADI_Analogdie_reg_write(unsigned int addr, int data); // idb
signed int __fastcall ADI_Analogdie_reg_read(unsigned int addr); // idb
int clock_init();
int __fastcall trace_write(int result);
int platform_init();
void __cdecl sleep(unsigned int);
BOOL read_test_mode();
BOOL read_usb_dload_en();
signed int sub_FFFF13F6();
int CheckSecureBootEnable();
signed int __fastcall usb_ldo_ctrl(int);
signed int usb_ref_clock_init();
signed int __fastcall HashVerify(int *, unsigned int);
int read_usb_hisgspeed_sel();
BOOL read_arm_boot_md0();
uint32 __fastcall sub_FFFF1516(int);
BOOL read_arm_boot_md1();
BOOL read_arm_boot_md3();
BOOL read_arm_boot_md2();
int __fastcall mmc_ldo_ctrl(int slot_number, int onOrOff, int volt_level); // idb
signed int emmc_setup_pin();
int __fastcall sim2_ldo_ctrl(int onOrOff); // idb
int __fastcall j_j___aeabi_memcpy(int, int, int, unsigned int);
int __fastcall memset(int result, unsigned __int8, unsigned int);
int __fastcall SPL_CheckSum(const unsigned int *src, int len); // idb
signed int nand_stuffs_1();
signed int disable_nfc();
signed int sub_FFFF176E();
int __fastcall sub_FFFF17C8(int a1);
int __fastcall sub_FFFF17EA(unsigned __int8 *a1);
int __fastcall sub_FFFF1812(unsigned __int8 *a1, int a2);
int __fastcall sub_FFFF18EC(unsigned __int16 *a1);
signed int __fastcall sub_FFFF1940(unsigned __int8 *, int);
signed int __fastcall sub_FFFF1B5C(int);
int __fastcall maybe_nand_read(int, int, int, unsigned int);
int __fastcall sub_FFFF1BCC(_BYTE *, int, unsigned int);
int __fastcall sub_FFFF1C84(unsigned __int8 *a1, int a2, int a3);
signed int __fastcall nand_stuffs_2(unsigned __int8 *a1);
signed int clear_uart_fifo();
BOOL __fastcall read_spl_from_nand(int, int, int, int);
int __cdecl main();
int __fastcall dl_verify_checksum(_BYTE *, unsigned int);
void __fastcall j___aeabi_memcpy(void *, const void *, size_t); // idb
// void __fastcall _aeabi_memcpy(void *, const void *, size_t); idb
// void __fastcall _aeabi_memcpy4(void *, const void *, size_t); idb
void __fastcall sub_FFFF21AC(unsigned int, unsigned int);
// _DWORD *__fastcall memset_w(_DWORD *result, unsigned int, int);
void *sub_FFFF232A();
void *sub_FFFF2380();
void *sub_FFFF2388();
// int __fastcall _aeabi_uidiv_div0(_DWORD, _DWORD); weak
int __fastcall jump_to(int);
unsigned int __fastcall asm_rev16(unsigned int);
unsigned int __fastcall sub_FFFF23C4(int);
// _DWORD *fp_init();
void __fastcall sub_FFFF2484(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4);
void __fastcall sub_FFFF2528(_DWORD *a1, unsigned int *a2, int a3);
unsigned int __fastcall sub_FFFF25C8(unsigned int result);
void __fastcall RSA_ModPower(int result, _DWORD *a2, unsigned int *a3, int a4);
_DWORD *__fastcall MD5Init(_DWORD *result);
int __fastcall sub_FFFF2714(int *, int *);
int __fastcall sub_FFFF3108(int result, int a2, int *a3);
int __fastcall MD5Final(int *a1, unsigned int a2, int *a3);
int efuse_get_timer_tick();
int efuse_parameter_config_1();
unsigned int efuse_parameter_config_2();
signed int __fastcall efuse_read(unsigned int, _DWORD *);
signed int __fastcall sub_FFFF32EE(unsigned int, int, int, int);
int __fastcall efuse_program_related(unsigned int, int, int, int);
signed int __fastcall sub_FFFF33BE(unsigned int, int, int, int);
signed int __fastcall sub_FFFF33E4(int, int, int, int);
int __fastcall sub_FFFF33FA(_DWORD *a1);
int __fastcall sub_FFFF3416(_DWORD *, int, int, int);
signed int __fastcall sub_FFFF3436(unsigned int a1, bool *a2);
int __fastcall sub_FFFF3460(int *a1, int *a2);
_DWORD *__fastcall sub_FFFF34A8(_DWORD *result, unsigned int *a2, unsigned int a3);

//-------------------------------------------------------------------------
// Data declarations

_DWORD dword_40000000[8]; // weak
int IRAM_SPL_MAGIC_OFFSET; // weak
int IRAM_SPL_CHECKSUM_OFFSET; // weak
_DWORD CHECKSUM_START_OFFSET[6134]; // weak
int g_TraceValue; // weak
int dword_40006004; // weak
int dword_40006008; // weak
struct SDIO_REG_CFG_TAG *mmc_selected;
struct UART_REG *uart_selected;
int dword_4000601C; // weak
_UNKNOWN unk_40006020; // weak
_UNKNOWN unk_4000605C; // weak
int dword_40006130; // weak
_BYTE byte_40006150[256]; // idb
int dword_40006250; // weak
int dword_40006254; // weak
unsigned __int8 byte_40006258[1024]; // idb
int efuse_hash_data[]; // weak
int dword_4000665C; // weak
int dword_40006660; // weak
int dword_40006664; // weak
int soft_hash_data[]; // weak
int dword_4000666C; // weak
int dword_40006670; // weak
int dword_40006674; // weak
_UNKNOWN unk_4000667C; // weak
int dword_40007E94; // weak
int dword_40007E98; // weak
int dword_40007E9C; // weak
int dword_40007EA0; // weak
int uart_dl_status; // weak
int current_uart_baudrate; // weak
_UNKNOWN unk_40007EB0; // weak
int dword_40007EB8; // weak
_UNKNOWN unk_40007EC4; // weak
_UNKNOWN unk_40007EC8; // weak
void (__fastcall *uart_dl_ops[5])(unsigned __int16 *, int) =
{
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1EF1,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F15,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F39,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F65,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F81
}; // idb
void *off_FFFF2454 = &unk_FFFF3508; // weak
int unk_FFFF3508[4798] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16777219,
  256,
  16908288,
  0,
  65537,
  65798,
  16843776,
  327681,
  117440513,
  65792,
  33554696,
  16846848,
  589826,
  285213184,
  131328,
  16843040,
  16851458,
  2163202,
  587333889,
  33685760,
  16843045,
  16852739,
  2360066,
  637731073,
  50462976,
  16843049,
  16853764,
  2622466,
  704905473,
  67240192,
  16777516,
  77314,
  2949634,
  788660480,
  33685504,
  16777521,
  78595,
  3146498,
  839057664,
  50462720,
  16777525,
  79620,
  3408898,
  906232064,
  67239936,
  65848,
  81410,
  3736064,
  1057095681,
  33554432,
  65851,
  82179,
  3801856,
  1073938433,
  50331648,
  65853,
  82692,
  3933184,
  1107558401,
  67108864,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb


//----- (FFFF0000) --------------------------------------------------------
void __noreturn reset()
{
  __set_CPSR(0xD3u);                            // Switch to SVC mode
  irom_enter();
}

//----- (FFFF0038) --------------------------------------------------------
void *sub_FFFF0038()
{
  return &unk_4000667C;
}

//----- (FFFF007C) --------------------------------------------------------
void __noreturn irom_enter()
{
  int v0; // r3

  if ( &off_FFFF2454 == (void **)sub_FFFF2484 )
    sub_FFFF00F4();
  v0 = (int)_scatterload_copy;
  if ( ((unsigned int)_scatterload_copy & 1) != 0 )
    v0 = 9123;
  ((void (__fastcall *)(int *, int *, int))(v0 | 1))(unk_FFFF3508, &g_TraceValue, 4);
}
// 40006000: using guessed type int g_TraceValue;
// FFFF2454: using guessed type void *off_FFFF2454;

//----- (FFFF00E8) --------------------------------------------------------
void sub_FFFF00E8()
{
  fp_init();
}

//----- (FFFF00F0) --------------------------------------------------------
void null_1()
{
  ;
}

//----- (FFFF00F4) --------------------------------------------------------
void __noreturn sub_FFFF00F4()
{
  int v0; // r0
  int v1; // r1

  sub_FFFF232A();
  sub_FFFF00E8();
  v0 = main();
  empty(v0, v1);
}
// FFFF237C: variable 'v1' is possibly undefined

//----- (FFFF0106) --------------------------------------------------------
void __fastcall __noreturn empty(int a1, int a2)
{
  null_1();
  die(a1, a2);
}

//----- (FFFF0114) --------------------------------------------------------
void *sub_FFFF0114()
{
  return &unk_FFFF23E8;
}

//----- (FFFF0118) --------------------------------------------------------
void *sub_FFFF0118()
{
  return &unk_FFFF23FC;
}

//----- (FFFF0124) --------------------------------------------------------
int __fastcall usb_send(_BYTE *a1, int a2)
{
  __int16 v4; // r0
  int v5; // r1

  v4 = dl_verify_checksum(a1, a2 - 2);
  a1[a2 - 2] = HIBYTE(v4);
  a1[a2 - 1] = v4;
  v5 = a2 + 2;
  a1[a2] = 0x7E;
  while ( v5 > 0 )
  {
    a1[v5] = a1[v5 - 1];
    --v5;
  }
  *a1 = 0x7E;
  return sub_FFFF09A6(5, (int)a1, a2 + 2);
}

//----- (FFFF0160) --------------------------------------------------------
int __fastcall usb_send_reply(unsigned int a1)
{
  unsigned __int16 v1; // r1
  struct BM_PACKAGE *v2; // r0

  v1 = asm_rev16(a1);
  v2 = packet_buf;
  packet_buf->header.type = v1;
  v2->header.len = 0;
  return usb_send(v2, 6);
}

//----- (FFFF017C) --------------------------------------------------------
signed int __fastcall read_usb(int a1, int a2, int a3, int a4)
{
  int v4; // r0
  int v5; // r1
  signed int result; // r0
  int v7; // r1
  int v8[6]; // [sp+0h] [bp-18h] BYREF

  v8[0] = a4;
  LOBYTE(v8[0]) = 0;
  while ( 1 )
  {
    result = dword_40006114;
    if ( dword_40006114 == 3 )
      break;
    while ( 1 )
    {
      while ( 1 )
      {
        v4 = usb_read(v8);
        if ( dword_40006114 )
          break;
        if ( v4 == 0x7E )
          dword_40006114 = 1;
      }
      if ( dword_40006114 != 1 )
        break;
      if ( v4 != 0x7E )
      {
        if ( v4 == 0x7D )
          LOBYTE(v4) = usb_read(v8) ^ 0x20;
        dword_40006114 = 2;
        v5 = dword_40006128;
        *(_BYTE *)dword_40006128 = v4;
        dword_40006128 = v5 + 1;
        ++dword_40006120;
      }
    }
    if ( dword_40006114 == 2 )
    {
      if ( v4 == 0x7E )
      {
        result = 3;
        dword_40006114 = 3;
        return result;
      }
      if ( v4 == 0x7D )
        LOBYTE(v4) = usb_read(v8) ^ 0x20;
      v7 = dword_40006128;
      *(_BYTE *)dword_40006128 = v4;
      dword_40006128 = v7 + 1;
      ++dword_40006120;
    }
  }
  return result;
}
// 40006114: using guessed type int dword_40006114;
// 40006120: using guessed type int dword_40006120;
// 40006128: using guessed type int dword_40006128;

//----- (FFFF01FC) --------------------------------------------------------
signed int __fastcall read_packet_from_usb(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  dword_40006120 = 0;
  dword_40006128 = dword_40006124;
  dword_40006114 = 0;
  read_usb(0, dword_40006124, a3, a4);
  if ( dl_verify_checksum((_BYTE *)dword_40006124, dword_40006120) )
    return 0x8B;                                // BSL_REP_VERIFY_ERROR
  *a1 = dword_40006124;
  *a2 = dword_40006120;
  return 0x8F;                                  // BSL_PHONE_SUCCEED
}
// 40006114: using guessed type int dword_40006114;
// 40006120: using guessed type int dword_40006120;
// 40006124: using guessed type int dword_40006124;
// 40006128: using guessed type int dword_40006128;

//----- (FFFF022C) --------------------------------------------------------
void __fastcall __noreturn usb_download_main(int a1, int a2, unsigned __int16 *a3, int a4)
{
  signed int v4; // r0
  unsigned int v5; // r0
  unsigned __int16 *v6; // [sp+0h] [bp-10h] BYREF
  int v7; // [sp+4h] [bp-Ch] BYREF

  v6 = a3;
  v7 = a4;
  while ( 1 )
  {
    v4 = read_packet_from_usb(&v6, &v7, (int)a3, a4);
    if ( v4 == 0x8F )                           // BSL_PHONE_SUCCEED
                                                // Read packet from usb succeeded (no CRC error)
    {
      v5 = asm_rev16(*v6);
      off_FFFF241C[v5](v6, v7);
    }
    else
    {
      usb_send_reply(v4);
      memset((int)&word_40007E8C, 0, 0x18u);
    }
  }
}
// FFFF0234: variable 'a3' is possibly undefined
// FFFF0234: variable 'a4' is possibly undefined
// 40007E8C: using guessed type __int16 word_40007E8C;
// FFFF241C: using guessed type void (__fastcall *off_FFFF241C[5])(unsigned __int16 *, int);

//----- (FFFF0260) --------------------------------------------------------
int __fastcall usb_dload_enter(int a1, int a2, int a3, int a4)
{
  unsigned __int16 ver_pkt_size; // r0
  int v5; // r0
  unsigned int v6; // r3
  int v7; // r0
  int v8; // r0
  int v9; // r1
  unsigned __int16 *v10; // r2
  int v11; // r3
  int v13; // [sp+0h] [bp-18h] BYREF

  v13 = a4;
  LOBYTE(v13) = 0;
  packet_buf = (struct BM_PACKAGE *)&INIT_STACK;
  dword_4000601C = (int)&unk_40007A8C;
  dword_4000611C = 1024;
  dword_40006124 = (int)&unk_40007A8C;
  dword_40006250 = 0;
  dword_40006254 = 0;
  do
  {
    if ( usb_read(&v13) == 0x7E && !(_BYTE)v13 )// wait for 0x7E
    {
      packet_buf->header.type = asm_rev16(0x81u);// BSL_REP_VER
      ver_pkt_size = get_ver_pkt_size();
      packet_buf->header.len = asm_rev16(ver_pkt_size);
      v5 = get_ver_pkt_size();
      j_j___aeabi_memcpy((int)&packet_buf->data, (int)"SPRD3", v5, v6);// Send version string
      v7 = get_ver_pkt_size();
      v8 = usb_send(packet_buf, v7 + 6);
      usb_download_main(v8, v9, v10, v11);
    }
  }
  while ( (unsigned __int8)v13 != 1 );
  return (unsigned __int8)v13;
}
// FFFF02C2: variable 'v6' is possibly undefined
// FFFF02D2: variable 'v9' is possibly undefined
// FFFF02D2: variable 'v10' is possibly undefined
// FFFF02D2: variable 'v11' is possibly undefined
// 4000601C: using guessed type int dword_4000601C;
// 4000611C: using guessed type int dword_4000611C;
// 40006124: using guessed type int dword_40006124;
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF02DC) --------------------------------------------------------
int dl_usb_connect()
{
  if ( byte_40007E90 != 1 )
  {
    usb_send_reply(0x80u);
    byte_40007E90 = 1;
  }
  return memset((int)&word_40007E8C, 0, 0x18u);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;

//----- (FFFF0300) --------------------------------------------------------
int __fastcall dl_usb_start_data(int a1)
{
  unsigned int v2; // r4
  unsigned int v3; // r0

  v2 = sub_FFFF23C4(*(_DWORD *)(a1 + 4));
  v3 = sub_FFFF23C4(*(_DWORD *)(a1 + 8));
  dword_40007E9C = v2;
  dword_40007EA0 = v2;
  dword_40007E94 = v3;
  return usb_send_reply(0x80u);
}
// 40007E94: using guessed type int dword_40007E94;
// 40007E9C: using guessed type int dword_40007E9C;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF0324) --------------------------------------------------------
int __fastcall dl_usb_midst_data(int a1)
{
  int v2; // r6
  unsigned int v3; // r3

  v2 = asm_rev16(*(unsigned __int16 *)(a1 + 2));
  j_j___aeabi_memcpy(dword_40007EA0, a1 + 4, v2, v3);
  dword_40007EA0 += v2;
  dword_40007E98 += v2;
  return usb_send_reply(0x80u);
}
// FFFF0338: variable 'v3' is possibly undefined
// 40007E98: using guessed type int dword_40007E98;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF0350) --------------------------------------------------------
int dl_usb_end_data()
{
  if ( dword_40007E98 == dword_40007E94 )
  {
    word_40007E8C = 143;
    return usb_send_reply(0x80u);
  }
  else
  {
    byte_40007E90 = 5;
    return usb_send_reply(0x8Bu);
  }
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007E94: using guessed type int dword_40007E94;
// 40007E98: using guessed type int dword_40007E98;

//----- (FFFF036C) --------------------------------------------------------
int dl_usb_exec()
{
  usb_send_reply(0x80u);
  sleep(0x12Cu);
  return jump_to(dword_40007E9C);
}
// 40007E9C: using guessed type int dword_40007E9C;

//----- (FFFF0388) --------------------------------------------------------
int __fastcall usb_init(int a1)
{
  MEMORY[0x2090020C] &= ~4u;                    // clear AHB_AHB_CTL3.BIT_USB_M_HBIGENDIAN
  MEMORY[0x20900200] |= 0x20u;                  // set AHB_CTL0.AHB_CTL0_USBD_EN
  usb_ldo_ctrl(1);
  usb_ref_clock_init();
  MEMORY[0x20900210] |= 0x80u;                  // set AHB_SOFT_RST.BIT_USBPHY_SOFT_RST
  sleep(0xAu);
  MEMORY[0x20900210] &= ~0x80u;                 // clear AHB_SOFT_RST.BIT_USBPHY_SOFT_RST
  MEMORY[0x8B000020] |= 0x5A00u;                // set GR_BOOT_FLAG.BITS_HWRST
  sleep(0x1Eu);
  return usb_core_init(a1);
}

//----- (FFFF03DC) --------------------------------------------------------
signed int arm_clock_config()
{
  signed int result; // r0
  unsigned int v1; // r1
  unsigned int v2; // r1

  result = 0x20900000;
  v1 = 0;
  MEMORY[0x20900224] |= 3u;                     // set AHB_ARM_CLK.BITS_CLK_ARM_DIV
  do
    ++v1;
  while ( v1 < 0xA );
  v2 = 0;
  MEMORY[0x20900224] |= 0x30u;                  // set AHB_ARM_CLK.BITS_CLK_AHB_DIV
  do
    ++v2;
  while ( v2 < 0xA );
  MEMORY[0x20900224] &= 0xFE7FFFFF;             // clear AHB_ARM_CLK.BITS_CLK_MCU_SEL
  return result;
}

//----- (FFFF0414) --------------------------------------------------------
int __fastcall usb_dload_start(int a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int result; // r0

  arm_clock_config();
  usb_init(a1);
  trace_write(2);
  result = usb_dload_enter(1, v2, v3, v4);
  if ( result != 1 )
  {
    while ( 1 )
      ;
  }
  return result;
}
// FFFF042C: variable 'v2' is possibly undefined
// FFFF042C: variable 'v3' is possibly undefined
// FFFF042C: variable 'v4' is possibly undefined

//----- (FFFF0464) --------------------------------------------------------
int __fastcall usb_endpoint_related(int a1, int a2)
{
  MEMORY[0x20300B10] |= 0x60000000u;
  MEMORY[0x20300B10] |= 0x18u;
  if ( a1 )
    MEMORY[0x20300B14] = a2;
  MEMORY[0x20300B00] |= 0x4000000u;
  MEMORY[0x20300B00] |= 0x80000000;
  return 0;
}

//----- (FFFF0496) --------------------------------------------------------
int __fastcall sub_FFFF0496(char a1, char a2, int a3, int a4)
{
  int result; // r0

  MEMORY[0x20300910] = MEMORY[0x20300910] & 0xFFE7FF80 | a1 & 0x7F | ((a2 & 3) << 19);
  if ( a3 )
    MEMORY[0x20300914] = a4;
  result = 0x20300900;
  MEMORY[0x20300900] &= 0xFC3FFFFF;
  MEMORY[0x20300900] |= 0x4000000u;
  MEMORY[0x20300900] |= 0x80000000;
  return result;
}

//----- (FFFF04D0) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF04D0(int a1, int a2)
{
  int v2; // r2
  int v3; // r1
  int v4; // r3
  _DWORD *result; // r0

  if ( a2 )
  {
    v2 = 12296;
    v3 = 540019456;
    v4 = 540018708;
  }
  else
  {
    v2 = -1;
    v4 = 540018704;
    v3 = 540018944;
  }
  result = (_DWORD *)(v3 + 32 * a1);
  *result |= 0x8000u;
  *(_DWORD *)v4 = v2;
  return result;
}

//----- (FFFF04FA) --------------------------------------------------------
unsigned int *__fastcall sub_FFFF04FA(int a1, char a2, int a3, __int16 a4)
{
  int v4; // r2
  unsigned int *result; // r0

  if ( a3 )
    v4 = 0x20300B00;                            // DOEPCTL0 Device Out Endpoint Control 0 
  else
    v4 = 0x20300900;                            // DIEPCTL0 Device In Endpoint Control 0 
  result = (unsigned int *)(v4 + 32 * a1);
  *result = *result & 0xFFF3FFFF | ((a2 & 3) << 18);
  *result = *result & 0xFFFFF800 | a4 & 0x7FF;
  *result |= 0x8000000u;
  return result;
}

//----- (FFFF0524) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF0524(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // r0

  if ( a2 )
  {
    if ( a4 )
      *(_DWORD *)(32 * a1 + 0x20300B14) = a5;
    *(_DWORD *)(32 * a1 + 0x20300B10) = (*(_DWORD *)(32 * a1 + 0x20300B10) >> 19 << 19) + 256;
    result = (_DWORD *)(32 * a1 + 540019456);
    *(_DWORD *)(32 * a1 + 0x20300B10) = *(_DWORD *)(32 * a1 + 0x20300B10) & 0xE007FFFF | 0x80000;
    *result = *(_DWORD *)(32 * a1 + 0x20300B00) | 0x4000000;
    *result = *(_DWORD *)(32 * a1 + 0x20300B00) | 0x80000000;
  }
  else
  {
    if ( a4 )
      *(_DWORD *)(32 * a1 + 0x20300914) = a5;
    *(_DWORD *)(32 * a1 + 0x20300910) = *(_DWORD *)(32 * a1 + 0x20300910) & 0xFFF80000 | a3 & 0x7FFFF;
    *(_DWORD *)(32 * a1 + 0x20300910) = *(_DWORD *)(32 * a1 + 0x20300910) & 0xE007FFFF | ((_aeabi_uidiv_div0(
                                                                                             (*(_DWORD *)(32 * a1 + 0x20300900) & 0x7FF)
                                                                                           + a3
                                                                                           - 1,
                                                                                             *(_DWORD *)(32 * a1 + 0x20300900) & 0x7FF) & 0x3FF) << 19);
    *(_DWORD *)(32 * a1 + 0x20300900) = *(_DWORD *)(32 * a1 + 0x20300900) & 0xFC3FFFFF | ((a1 & 0xF) << 22);
    *(_DWORD *)(32 * a1 + 0x20300900) |= 0x4000000u;
    result = (_DWORD *)(*(_DWORD *)(32 * a1 + 0x20300900) | 0x80000000);
    *(_DWORD *)(32 * a1 + 0x20300900) = result;
  }
  return result;
}
// FFFF2390: using guessed type int __fastcall _aeabi_uidiv_div0(_DWORD, _DWORD);

//----- (FFFF05C4) --------------------------------------------------------
int __fastcall sub_FFFF05C4(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // r4
  int result; // r0
  void *v7; // r3
  int v8; // r0

  v5 = (unsigned __int8)BYTE2(*a2);
  result = HIBYTE(*a1);
  if ( result == 1 )
  {
    v7 = (void *)sub_FFFF0114();
    v8 = 18;
  }
  else
  {
    if ( result != 2 )
      return result;
    v7 = sub_FFFF0118();
    if ( v5 == 255 )
      v8 = 32;
    else
      v8 = v5;
  }
  return sub_FFFF0496(v8, 1, 1, v7, a5);
}
// FFFF0496: using guessed type int __fastcall sub_FFFF0496(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (FFFF0604) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF0604(char a1)
{
  int v2; // r4
  _DWORD *result; // r0
  int v4; // r0

  v2 = a1 & 0x7F;
  result = (_DWORD *)sub_FFFF0496(0, 1, 0, 0);
  if ( v2 )
  {
    if ( (a1 & 0x80) != 0 )
      v4 = 540018944;
    else
      v4 = 540019456;
    result = (_DWORD *)(v4 + 32 * v2);
    *result |= 0x10000000u;
  }
  return result;
}

//----- (FFFF0638) --------------------------------------------------------
int __fastcall sub_FFFF0638(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r2
  int result; // r0
  int v6; // r2
  int *v7; // r3
  int v8; // r0
  int v9[2]; // [sp+0h] [bp-8h] BYREF

  v9[0] = 0;
  v4 = ((unsigned int)dword_40006130 >> 5) & 3;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        v6 = 1;
        v7 = v9;
        v8 = 4;
        return sub_FFFF0496(v8, 1, v6, v7, v9[0]);
      }
      goto LABEL_19;
    }
    if ( (dword_40006130 & 0x1F) != 1 )
    {
LABEL_19:
      v7 = 0;
      goto LABEL_10;
    }
    if ( BYTE2(dword_40006130) == 1 && HIBYTE(dword_40006130) == 6 )
    {
      sub_FFFF04D0(5, 0);
      sub_FFFF04D0(6, 1);
    }
LABEL_14:
    v7 = 0;
    v6 = 0;
    goto LABEL_15;
  }
  switch ( BYTE1(dword_40006130) )
  {
    case 1u:
      result = dword_40006130 & 0x1F;
      if ( result == 2 )
        return sub_FFFF0604(LOBYTE(dword_40006134[0]));
      break;
    case 5u:
      MEMORY[0x20300800] = MEMORY[0x20300800] & 0xFFFFF80F | (16 * (BYTE2(dword_40006130) & 0x7F));
      goto LABEL_14;
    case 6u:
      return sub_FFFF05C4(&dword_40006130, dword_40006134, 6, a4, v9[0]);
    case 9u:
      goto LABEL_14;
    default:
      v7 = v9;
LABEL_10:
      v6 = 1;
LABEL_15:
      v8 = 0;
      return sub_FFFF0496(v8, 1, v6, v7, v9[0]);
  }
  return result;
}
// 40006130: using guessed type int dword_40006130;
// 40006134: using guessed type int dword_40006134[7];
// FFFF0496: using guessed type int __fastcall sub_FFFF0496(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// FFFF04D0: using guessed type int __fastcall sub_FFFF04D0(_DWORD, _DWORD);
// FFFF0604: using guessed type int __fastcall sub_FFFF0604(_DWORD);

//----- (FFFF06EC) --------------------------------------------------------
int usb_reset_handler()
{
  unsigned int v0; // r0
  unsigned int v1; // r0
  int result; // r0

  MEMORY[0x20300018] &= ~0x1000u;
  MEMORY[0x20300B00] |= 0x8000000u;
  MEMORY[0x20300BC0] |= 0x8000000u;
  MEMORY[0x2030081C] |= 0x10001u;
  MEMORY[0x20300814] |= 0xFu;
  v0 = 0;
  MEMORY[0x20300810] |= 0x2Fu;
  MEMORY[0x20300024] = 0x214;
  MEMORY[0x20300028] = 0x200214;
  MEMORY[0x20300114] = 0x800234;
  MEMORY[0x20300010] |= 0x20u;
  do
  {
    if ( (MEMORY[0x20300010] & 0x20) == 0 )
      break;
    ++v0;
  }
  while ( v0 < 0x3E80 );
  v1 = 0;
  MEMORY[0x20300010] |= 0x10u;
  do
  {
    if ( (MEMORY[0x20300010] & 0x10) == 0 )
      break;
    ++v1;
  }
  while ( v1 < 0x3E80 );
  usb_endpoint_related(1, (int)&dword_40006130);
  MEMORY[0x20300018] |= 0x1000u;
  result = MEMORY[0x20300014] | 0x1000;
  MEMORY[0x20300014] |= 0x1000u;
  return result;
}
// 40006130: using guessed type int dword_40006130;

//----- (FFFF0794) --------------------------------------------------------
int usb_enumeration_done()
{
  int result; // r0

  dword_40006004 = (MEMORY[0x20300808] >> 1) & 3;
  MEMORY[0x20300900] &= 0xFFFFFFFC;
  sub_FFFF04FA(5, 2, 0, 64);
  sub_FFFF04FA(6, 2, 1, 64);
  usb_endpoint_related(1, (int)&dword_40006130);
  MEMORY[0x20300804] |= 0x100u;
  result = MEMORY[0x20300014] | 0x2000;
  MEMORY[0x20300014] |= 0x2000u;
  return result;
}
// 40006004: using guessed type int dword_40006004;
// 40006130: using guessed type int dword_40006130;

//----- (FFFF07E8) --------------------------------------------------------
int sub_FFFF07E8()
{
  unsigned int v0; // r1
  unsigned int v1; // r2
  char v2; // r6
  int v3; // r5
  int result; // r0
  int v5; // [sp+0h] [bp-18h]

  v5 = MEMORY[0x20300814] & MEMORY[0x20300BC8];
  if ( !((MEMORY[0x20300814] & MEMORY[0x20300BC8]) << 31) )
  {
    if ( (v5 & 0x2000) != 0 )
    {
      sub_FFFF0524(6, 1, 1, 1, (int)byte_40006150);
      MEMORY[0x20300814] &= ~0x2000u;
      MEMORY[0x20300814] |= 1u;
      result = MEMORY[0x20300BC8] | 0x2000;
    }
    else
    {
      result = v5 << 19;
      if ( (v5 & 0x1000) == 0 )
        return result;
      result = MEMORY[0x20300BC8] | 0x1000;
    }
    MEMORY[0x20300BC8] = result;
    return result;
  }
  MEMORY[0x20300BC8] |= 1u;
  v0 = 0;
  v1 = 256 - (MEMORY[0x20300BD0] & 0x7FFFF);
  dword_40006008 = v1;
  while ( v0 < v1 )
  {
    v2 = byte_40006150[v0];
    v3 = dword_40006254++;
    *((_BYTE *)&dword_40006250 + v3 + 8) = v2;
    if ( (unsigned int)dword_40006254 >= 0x400 )
      dword_40006254 = 0;
    ++v0;
  }
  MEMORY[0x20300814] |= 0x2000u;
  MEMORY[0x20300814] |= 0x10u;
  result = MEMORY[0x20300814] & 0xFFFFFFFE;
  MEMORY[0x20300814] &= ~1u;
  return result;
}
// 40006008: using guessed type int dword_40006008;
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF08C4) --------------------------------------------------------
int __fastcall sub_FFFF08C4(int a1, int a2, int a3, int a4)
{
  if ( (MEMORY[0x20300B08] & 8) != 0 )
    sub_FFFF0638(MEMORY[0x20300B08] << 28, a2, a3, a4);
  if ( MEMORY[0x20300B08] << 31 )
  {
    MEMORY[0x20300B00] |= 0x8000000u;
    MEMORY[0x20300B08] |= 1u;
  }
  if ( (MEMORY[0x20300B08] & 0x10) != 0 )
    MEMORY[0x20300B08] |= 0x10u;
  MEMORY[0x20300B08] = -1;
  return usb_endpoint_related(1, (int)&dword_40006130);
}
// 40006130: using guessed type int dword_40006130;

//----- (FFFF090A) --------------------------------------------------------
int __fastcall usb_EP_out_handle(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v5; // [sp+0h] [bp-10h]

  v5 = MEMORY[0x20300818];
  MEMORY[0x20300018] &= ~0x80000u;
  if ( (MEMORY[0x20300818] & 0x10000) != 0 )
    sub_FFFF08C4(MEMORY[0x20300818] << 15, a2, a3, a4);
  if ( (v5 & 0x400000) != 0 )
    sub_FFFF07E8();
  result = MEMORY[0x20300018] | 0x80000;
  MEMORY[0x20300018] |= 0x80000u;
  return result;
}

//----- (FFFF093A) --------------------------------------------------------
signed int maybe_some_usb_interrupts_1()
{
  signed int result; // r0

  result = 0x20300000;
  MEMORY[0x20300018] &= ~0x40000u;              // GINTMSK unmask OEPINTMSK 
  if ( MEMORY[0x20300818] << 31 )
    MEMORY[0x20300908] = 0xFFFFFFFF;
  if ( (MEMORY[0x20300818] & 0x20) != 0 )
    MEMORY[0x203009A8] = 0xFFFFFFFF;
  MEMORY[0x20300018] |= 0x40000u;               // GINTMSK mask OEPINTMSK 
  return result;
}

//----- (FFFF0970) --------------------------------------------------------
int __fastcall usb_handler(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v5; // [sp+0h] [bp-8h]

  v5 = MEMORY[0x20300014];
  if ( (MEMORY[0x20300014] & 0x40000) != 0 )
    maybe_some_usb_interrupts_1();
  if ( (v5 & 0x80000) != 0 )
    usb_EP_out_handle(v5 << 12, a2, a3, a4);
  if ( (v5 & 0x2000) != 0 )
    usb_enumeration_done();
  result = v5 << 19;
  if ( (v5 & 0x1000) != 0 )
    return usb_reset_handler();
  return result;
}
// FFFF098A: variable 'a2' is possibly undefined
// FFFF098A: variable 'a3' is possibly undefined
// FFFF098A: variable 'a4' is possibly undefined

//----- (FFFF09A6) --------------------------------------------------------
int __fastcall sub_FFFF09A6(int a1, int a2, int a3)
{
  sub_FFFF0524(a1, 0, a3, 1, a2);
  return 0;
}

//----- (FFFF09B6) --------------------------------------------------------
int __fastcall usb_core_init(int a1)
{
  unsigned int v1; // r2
  bool v2; // zf
  int result; // r0

  v1 = 0;
  MEMORY[0x20300010] |= 1u;                     // CSFTRST reset the usb core
  do
  {
    if ( MEMORY[0x20300010] < 0 )
      break;
    ++v1;
  }
  while ( v1 < 3 );
  MEMORY[0x20300008] |= 0x20u;
  MEMORY[0x20300008] |= 0xEu;
  MEMORY[0x20300008] |= 1u;
  MEMORY[0x2030000C] &= ~0x40u;
  MEMORY[0x2030000C] &= ~0x20000u;
  MEMORY[0x2030000C] &= ~0x10u;
  MEMORY[0x2030000C] |= 8u;
  MEMORY[0x2030000C] &= 0xFFFFFFF8;
  MEMORY[0x2030000C] |= 0x1400u;
  MEMORY[0x20300014] = -1;
  MEMORY[0x20300800] &= ~4u;
  MEMORY[0x20300800] &= 0xFFFFE7FF;
  v2 = a1 == 0;
  result = 0xC3000;
  MEMORY[0x20300018] = 0xC3000;
  if ( v2 )
  {
    result = MEMORY[0x20300800] | 1;
    MEMORY[0x20300800] |= 1u;
  }
  return result;
}

//----- (FFFF0A6C) --------------------------------------------------------
int __fastcall maybe_usb_read(_BYTE *a1)
{
  int v1; // r7
  int v3; // r9
  unsigned int timer_tick; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  unsigned int v8; // r6

  v1 = 1;
  v3 = 0;
  timer_tick = get_timer_tick();
  v8 = timer_tick;
  while ( 1 )
  {
    usb_handler(timer_tick, v5, v6, v7);
    if ( dword_40006250 != dword_40006254 )
    {
      v3 = byte_40006258[dword_40006250];
      if ( (unsigned int)++dword_40006250 >= 0x400 )
        dword_40006250 = 0;
      v1 = 0;
    }
    timer_tick = get_timer_tick() - v8;
    if ( timer_tick > 0x3E80 )
      break;
    if ( !v1 )
      return v3;
  }
  if ( a1 )
  {
    *a1 = 1;
    trace_write(4);
  }
  return v3;
}
// FFFF0A8C: variable 'v5' is possibly undefined
// FFFF0A8C: variable 'v6' is possibly undefined
// FFFF0A8C: variable 'v7' is possibly undefined
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF0AF0) --------------------------------------------------------
int read_uart()
{
  struct UART_REG *v0; // r0
  int result; // r0
  uint32 uart_rx; // r2
  int v4; // r0
  int v5; // r0

  v0 = uart_selected;
  while ( (unsigned __int8)uart_selected->UART_STS1 )
    ;
  if ( uart_dl_status == 0x85 )                 // BSL_REP_NOT_SUPPORT_BAUDRATE
  {
    while ( 1 )
    {
      while ( !(unsigned __int8)v0->UART_STS1 )
        ;
      if ( (v0->UART_STS0 & 0x80) == 0 )
        break;
      v0->UART_ICLR |= 0x80u;
    }
    if ( v0->UART_RXD == 0x7E )
    {
      result = 0x90;
      uart_dl_status = 0x90;                    // BSL_PHONE_VALID_BAUDRATE
    }
    else
    {
      result = 15000;
      while ( result-- != 0 )
        ;
    }
  }
  else
  {
    while ( 1 )
    {
      result = dword_40007EA8;
      if ( dword_40007EA8 == 3 )
        break;
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( !(unsigned __int8)uart_selected->UART_STS1 )
              ;
            uart_rx = uart_selected->UART_RXD;
            if ( (uart_selected->UART_STS0 & 0x80) == 0 )
              break;
            uart_selected->UART_ICLR |= 0x80u;
          }
          if ( dword_40007EA8 )
            break;
          if ( uart_rx == 0x7E )
            dword_40007EA8 = 1;
        }
        if ( dword_40007EA8 != 1 )
          break;
        if ( uart_rx != 0x7E )
        {
          if ( uart_rx == 0x7D )
          {
            while ( !(unsigned __int8)uart_selected->UART_STS1 )
              ;
            uart_rx = uart_selected->UART_RXD ^ 0x20;
          }
          dword_40007EA8 = 2;
          v4 = dword_40007EBC;
          *(_BYTE *)dword_40007EBC = uart_rx;
          dword_40007EBC = v4 + 1;
          ++dword_40007EB4;
        }
      }
      if ( dword_40007EA8 == 2 )
      {
        if ( uart_rx == 0x7E )
        {
          result = 3;
          dword_40007EA8 = 3;
          return result;
        }
        if ( uart_rx == 0x7D )
        {
          while ( !(unsigned __int8)uart_selected->UART_STS1 )
            ;
          uart_rx = uart_selected->UART_RXD ^ 0x20;
        }
        v5 = dword_40007EBC;
        *(_BYTE *)dword_40007EBC = uart_rx;
        dword_40007EBC = v5 + 1;
        ++dword_40007EB4;
      }
    }
  }
  return result;
}
// 40007EA4: using guessed type int uart_dl_status;
// 40007EA8: using guessed type int dword_40007EA8;
// 40007EB4: using guessed type int dword_40007EB4;
// 40007EBC: using guessed type int dword_40007EBC;

//----- (FFFF0BCA) --------------------------------------------------------
int __fastcall uart_read_for_baudrate(struct UART_REG *a1)
{
  MEMORY[0x8B000008] |= 0x300000u;              // GEN0 maybe enable uart
  a1->UART_IEN = 0;                             // Disable uart interrupt
  a1->UART_CKD0 = current_uart_baudrate;        // UART_CKD0 Divisor is (n+1)*2 ,baudrate
  a1->UART_CTRL0 = 0x1C;                        // UART_CTRL0 1stop bit, data byte length = 8bits 
  a1->UART_CTRL1 = 0;                           // UART_CTRL1 mainly DMA, disable everything
  a1->UART_CTRL2 = 0;                           // UART_CTRL2 
                                                // UART TX FIFO empty and RX FIFO full watermark register 
  return read_uart();
}
// 40007EAC: using guessed type int current_uart_baudrate;

//----- (FFFF0BEE) --------------------------------------------------------
// ResearchDownload detects uart baudrate at every download
int check_uart_baudrate()
{
  int result; // r0

  uart_dl_status = 0x85;
  current_uart_baudrate = 0xE2;
  unk_40007EB0 = 0x400;
  dword_40007EB8 = dword_4000601C;
  while ( 1 )
  {
    uart_read_for_baudrate(uart_selected);
    result = uart_dl_status;
    if ( uart_dl_status == 0x90 )
      break;
    current_uart_baudrate = (unsigned int)current_uart_baudrate >> 1;
  }
  return result;
}
// 4000601C: using guessed type int dword_4000601C;
// 40007EA4: using guessed type int uart_dl_status;
// 40007EAC: using guessed type int current_uart_baudrate;
// 40007EB8: using guessed type int dword_40007EB8;

//----- (FFFF0C1E) --------------------------------------------------------
struct UART_REG *__fastcall uart_send(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v3; // r5
  __int16 v4; // r0
  volatile uint32 v5; // r1
  int v6; // r4
  struct UART_REG *result; // r0
  volatile uint32 v8; // t1

  v3 = a1;
  v4 = dl_verify_checksum(a1, a2 - 2);
  v5 = 0x7E;
  v3[a2 - 2] = HIBYTE(v4);
  v3[a2 - 1] = v4;
  v3[a2] = 0x7E;
  v6 = a2 + 1;
  result = uart_selected;
  while ( (uart_selected->UART_STS1 & 0xFF00) != 0 )
    ;
  while ( 1 )
  {
    result->UART_TXD = v5;
    if ( !v6 )
      break;
    while ( (result->UART_STS1 & 0xFF00) != 0 )
      ;
    v8 = *v3++;
    v5 = v8;
    --v6;
  }
  while ( (result->UART_STS1 & 0xFF00) != 0 )
    ;
  return result;
}

//----- (FFFF0C64) --------------------------------------------------------
signed int __fastcall read_packet_from_uart(_DWORD *a1, _DWORD *a2)
{
  dword_40007EB4 = 0;
  dword_40007EBC = dword_40007EB8;
  dword_40007EA8 = 0;
  read_uart();
  if ( dl_verify_checksum((_BYTE *)dword_40007EB8, dword_40007EB4) )
    return 0x8B;                                // BSL_REP_VERIFY_ERROR
  *a1 = dword_40007EB8;
  *a2 = dword_40007EB4;
  return 0x8F;                                  // BSL_PHONE_SUCCEED
}
// 40007EA8: using guessed type int dword_40007EA8;
// 40007EB4: using guessed type int dword_40007EB4;
// 40007EB8: using guessed type int dword_40007EB8;
// 40007EBC: using guessed type int dword_40007EBC;

//----- (FFFF0C94) --------------------------------------------------------
_DWORD *__fastcall uart_setup(_DWORD *result)
{
  result[4] = 0;
  result[9] = 226;
  result[6] = 28;
  result[7] = 0;
  result[8] = 0;
  return result;
}

//----- (FFFF0CA6) --------------------------------------------------------
uint32 __fastcall uart_trace(unsigned __int8 *a1, int a2)
{
  struct UART_REG *v2; // r2
  volatile uint32 v3; // t1
  volatile uint32 result; // r0

  v2 = uart_selected;
  while ( a2 )
  {
    while ( (v2->UART_STS1 & 0xFF00) != 0 )
      ;
    v3 = *a1++;
    --a2;
    v2->UART_TXD = v3;
  }
  do
    result = v2->UART_STS1;
  while ( (result & 0xFF00) != 0 );
  return result;
}

//----- (FFFF0CD8) --------------------------------------------------------
BOOL sub_FFFF0CD8()
{
  int timer_tick; // r0
  int v1; // r4
  struct SDIO_REG_CFG_TAG *v2; // r1
  volatile uint32 HOST_CTL1; // r6

  timer_tick = get_timer_tick();
  v1 = timer_tick;
  v2 = mmc_selected;
  mmc_selected->HOST_CTL1 |= 0x1000000u;
  HOST_CTL1 = v2->HOST_CTL1;
  while ( (HOST_CTL1 & 0x1000000) != 0 && (unsigned int)(timer_tick - v1) < 0x64 )
  {
    HOST_CTL1 = mmc_selected->HOST_CTL1;
    timer_tick = get_timer_tick();
  }
  return (unsigned int)(timer_tick - v1) <= 0x64;
}

//----- (FFFF0D34) --------------------------------------------------------
unsigned int __fastcall sub_FFFF0D34(int a1)
{
  unsigned int result; // r0
  unsigned int v3; // r5
  struct SDIO_REG_CFG_TAG *v4; // r1
  volatile uint32 HOST_CTL1; // r6

  result = get_timer_tick();
  v3 = result;
  if ( a1 == 1 )
  {
    v4 = mmc_selected;
    mmc_selected->HOST_CTL1 |= 1u;
    HOST_CTL1 = v4->HOST_CTL1;
    while ( (HOST_CTL1 & 2) == 0 )
    {
      result -= v3;
      if ( result >= 0x64 )
        break;
      HOST_CTL1 = mmc_selected->HOST_CTL1;
      result = get_timer_tick();
    }
  }
  else
  {
    result = (unsigned int)mmc_selected;
    mmc_selected->HOST_CTL1 &= ~1u;
  }
  return result;
}

//----- (FFFF0DA0) --------------------------------------------------------
SDIO_REG_CFG_TAG *__fastcall sub_FFFF0DA0(int a1)
{
  SDIO_REG_CFG_TAG *v1; // r6
  int timer_tick; // r5
  SDIO_REG_CFG_TAG *result; // r0
  volatile uint32 HOST_CTL1; // r7

  timer_tick = get_timer_tick();
  if ( a1 == 1 )
  {
    sub_FFFF0D34(1);
    result = mmc_selected;
    mmc_selected->HOST_CTL1 |= 4u;
    HOST_CTL1 = result->HOST_CTL1;
    while ( (HOST_CTL1 & 2) == 0 )
    {
      result = (SDIO_REG_CFG_TAG *)((char *)v1 - timer_tick);
      if ( (unsigned int)v1 - timer_tick >= 0x64 )
        break;
      HOST_CTL1 = mmc_selected->HOST_CTL1;
      result = (SDIO_REG_CFG_TAG *)get_timer_tick();
      v1 = result;
    }
  }
  else
  {
    result = mmc_selected;
    mmc_selected->HOST_CTL1 &= ~4u;
  }
  return result;
}
// FFFF0E08: variable 'v1' is possibly undefined

//----- (FFFF0E18) --------------------------------------------------------
SDIO_REG_CFG_TAG *sub_FFFF0E18()
{
  SDIO_REG_CFG_TAG *v0; // r0

  v0 = mmc_selected;
  mmc_selected->HOST_CTL0 &= ~2u;
  v0->HOST_CTL0 &= ~4u;
  v0->HOST_CTL1 = v0->HOST_CTL1 & 0xFFFF00FF | 0x800;
  sub_FFFF0D34(1);
  return sub_FFFF0DA0(1);
}

//----- (FFFF0E60) --------------------------------------------------------
BOOL __fastcall select_mmc_slot(int a1)
{
  bool slot_number; // zf
  unsigned int v2; // r0

  slot_number = a1 == 0;
  v2 = 0;
  mmc_selected = (struct SDIO_REG_CFG_TAG *)0x20500000;
  if ( slot_number )
  {
    MEMORY[0x20900200] |= 0x10u;
    MEMORY[0x20900210] |= 0x1000u;
    do
      ++v2;
    while ( v2 < 0xFF );
    MEMORY[0x20900210] &= ~0x1000u;
    MEMORY[0x20900228] &= 0xFFFFFFFC;
    MEMORY[0x8C0000A4] &= 0xFFFFFCFF;
    MEMORY[0x8C0000A4] |= 0x200u;
    mmc_selected = (struct SDIO_REG_CFG_TAG *)0x20500000;// SDIO0
  }
  else
  {
    MEMORY[0x20900200] |= 0x80000u;
    MEMORY[0x20900210] |= 0x10000u;
    do
      ++v2;
    while ( v2 < 0xFF );
    MEMORY[0x20900210] &= ~0x10000u;
    MEMORY[0x20900228] &= 0xFFFFFFF3;
    MEMORY[0x8C0003E8] &= 0xFFFFFCFF;
    MEMORY[0x8C0003E8] |= 0x200u;
    mmc_selected = (struct SDIO_REG_CFG_TAG *)0x20600000;// SDIO1
  }
  return sub_FFFF0CD8();
}

//----- (FFFF0F44) --------------------------------------------------------
uint32 __fastcall sub_FFFF0F44(int a1)
{
  struct SDIO_REG_CFG_TAG *v1; // r1
  volatile uint32 INT_STA_EN; // r2
  uint32 result; // r0

  v1 = mmc_selected;
  INT_STA_EN = mmc_selected->INT_STA_EN;
  mmc_selected->INT_STA_EN = INT_STA_EN & 0xFFEFFFFF;
  result = v1->HOST_CTL1 & 0xFFF0FFFF | (a1 << 16);
  v1->HOST_CTL1 = result;
  v1->INT_STA_EN = INT_STA_EN;
  return result;
}

//----- (FFFF0F74) --------------------------------------------------------
signed int __fastcall emmc_read_boot0(int a1, volatile uint32 a2)
{
  struct SDIO_REG_CFG_TAG *v4; // r1
  struct SDIO_REG_CFG_TAG *v5; // r2
  struct SDIO_REG_CFG_TAG *v6; // r0
  int timer_tick; // r0
  int v8; // r5
  volatile uint32 INT_STA; // r0

  v4 = mmc_selected;
  mmc_selected->INT_SIG_EN = 0;
  v4->INT_STA_EN = 0;
  sub_FFFF0F44(14);
  v5 = mmc_selected;
  mmc_selected->INT_STA = 0x70800B;
  v5->INT_STA_EN = 7340043;
  v5->INT_SIG_EN = 7340043;
  v5->DMA_SYS_ADD = a2;
  v6 = mmc_selected;
  mmc_selected->BLK_SIZE_COUNT = (a1 << 16) | 0x7200;
  v6->CMD_ARGUMENT = -6;
  v6->CMD_TRANSMODE = 0x200033;
  timer_tick = get_timer_tick();
  v8 = timer_tick;
  while ( (unsigned int)(timer_tick - v8) < 0x7D0 )
  {
    INT_STA = mmc_selected->INT_STA;
    if ( (INT_STA & 0x708000) != 0 )
      break;
    if ( (~INT_STA & 3) == 0 )
      return 1;
    timer_tick = get_timer_tick();
  }
  return 0;
}

//----- (FFFF1020) --------------------------------------------------------
signed int sub_FFFF1020()
{
  struct SDIO_REG_CFG_TAG *v0; // r0
  struct SDIO_REG_CFG_TAG *v1; // r0
  int timer_tick; // r0
  int v3; // r4
  volatile uint32 INT_STA; // r0

  v0 = mmc_selected;
  mmc_selected->INT_SIG_EN = 0;
  v0->INT_STA_EN = 0;
  sub_FFFF0F44(14);
  v1 = mmc_selected;
  mmc_selected->INT_STA = 1;
  v1->INT_STA_EN = 1;
  v1->INT_SIG_EN = 1;
  v1->CMD_ARGUMENT = -252645136;
  v1->CMD_TRANSMODE = 0;
  timer_tick = get_timer_tick();
  v3 = timer_tick;
  while ( (unsigned int)(timer_tick - v3) < 0x64 )
  {
    INT_STA = mmc_selected->INT_STA;
    if ( (INT_STA & 0x8000) != 0 )
      break;
    if ( (INT_STA & 1) != 0 )
      return 1;
    timer_tick = get_timer_tick();
  }
  return 0;
}

//----- (FFFF10C4) --------------------------------------------------------
BOOL SPL_Check()
{
  return IRAM_SPL_MAGIC_OFFSET == 0xAA55A5A5 && IRAM_SPL_CHECKSUM_OFFSET == SPL_CheckSum(CHECKSUM_START_OFFSET, 24536);
}
/* Orphan comments:
refer to fastboot_splFillCheckData in u-boot
*/
// 40000020: using guessed type int IRAM_SPL_MAGIC_OFFSET;
// 40000024: using guessed type int IRAM_SPL_CHECKSUM_OFFSET;
// 40000028: using guessed type _DWORD CHECKSUM_START_OFFSET[6134];

//----- (FFFF1100) --------------------------------------------------------
signed int read_spl_from_emmc()
{
  int boot_mmc_slot; // r6
  int volt_level; // r5
  int attempt_count; // r4
  int trace_value; // r0

  emmc_setup_pin();
  boot_mmc_slot = read_arm_boot_md3();
  volt_level = read_arm_boot_md2();
  attempt_count = 0;
  while ( 1 )
  {
    sim2_ldo_ctrl(1);
    mmc_ldo_ctrl(boot_mmc_slot, 1, volt_level);
    select_mmc_slot(boot_mmc_slot);
    sub_FFFF0E18();
    trace_write(0x80000);
    sleep(2u);
    if ( sub_FFFF1020() == 1 )
      break;
    trace_value = 0x100000;
LABEL_5:
    trace_write(trace_value);
    mmc_ldo_ctrl(boot_mmc_slot, 0, volt_level);
    sim2_ldo_ctrl(0);
    sleep(0x32u);
    if ( (unsigned int)++attempt_count >= 2 )   // Try it twice
      return 0;
  }
  sleep(2u);
  if ( emmc_read_boot0(48, 0x40000000u) != 1 )  // Read 48 sectors (24kbytes) from EMMC BOOT0 to IRAM_BASE
  {
    trace_value = 0x200000;
    goto LABEL_5;
  }
  if ( !SPL_Check() )
  {
    trace_value = 0x400000;
    goto LABEL_5;
  }
  trace_write(0x800000);
  return 1;
}

//----- (FFFF11DC) --------------------------------------------------------
signed int mpll_enable()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x8B00000C] |= 2u;                     // Set GR_PCTL.MCU_MPLL_EN
  return result;
}

//----- (FFFF11EA) --------------------------------------------------------
signed int chip_pin_init()
{
  _DWORD *v0; // r0
  _DWORD *i; // r0
  signed int result; // r0

  v0 = (_DWORD *)0x8C0000E0;
  MEMORY[0x8B000008] |= 0x2000u;                // set GR_GEN0.GEN0_PIN_EN
  MEMORY[0x8B000008] |= 0x4000100u;             // set GR_GEN0.GEN0_KPD_EN, GR_GEN0.GEN0_KPD_RTC_EN
  do                                            // 0x8C0000E0 - 0x8C0000FC KEYIN[0-7] set
    *v0++ |= 0x80u;
  while ( (unsigned int)v0 <= 0x8C0000FC );     // KEYIN set end
  for ( i = (_DWORD *)0x8C00019C; (unsigned int)i <= 0x8C0002A8; ++i )
  {
    *i &= ~0x100u;                              // reset EMC
    *i |= 0x200u;
  }
  result = 0x8C000000;
  MEMORY[0x8C000000] |= 0x3000u;                // Chip pin registers 
  return result;
}

//----- (FFFF1238) --------------------------------------------------------
signed int timer_enable()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x8B000008] |= 0x8080000u;             // set GEN0 bit[19] SYST_EN, bit[27] SYST_RTC_EN
  return result;
}

//----- (FFFF1246) --------------------------------------------------------
_DWORD *uart_init()
{
  MEMORY[0x8B00000C] &= ~0x100u;
  MEMORY[0x8B00005C] |= 0xF00000u;
  MEMORY[0x8B000008] |= 0x300000u;
  uart_setup((_DWORD *)0x83000000);
  return uart_setup((_DWORD *)0x84000000);
}

//----- (FFFF1278) --------------------------------------------------------
int keypad_init()
{
  int v0; // r1
  int result; // r0

  v0 = 0;
  MEMORY[0x8B000008] |= 0x4000100u;
  MEMORY[0x8B00004C] |= 2u;
  do
    ++v0;
  while ( v0 < 10 );
  MEMORY[0x8B00004C] &= ~2u;
  MEMORY[0x87000010] = 0xFFF;
  MEMORY[0x87000018] = 0xFFFF;
  MEMORY[0x87000028] = 0;
  MEMORY[0x8700001C] = 0xF;                     // KPD_DEBOUNCE_CNT Counter for de-bounce time 
  result = MEMORY[0x87000000] | 1;
  MEMORY[0x87000000] |= 1u;                     // KPD_EN enable keypad
  return result;
}

//----- (FFFF12C0) --------------------------------------------------------
int ADI_init()
{
  int v0; // r1
  int result; // r0

  MEMORY[0x8B000008] |= 0x40u;                  // enable ADI_ACC to put the adi master to normal operation mode
  MEMORY[0x8B00004C] |= 0x400000u;              // reset ADI module
  v0 = 50;
  while ( v0-- != 0 )
    ;
  MEMORY[0x8B00004C] &= ~0x400000u;             // Out of reset
  MEMORY[0x82000004] &= ~2u;                    // ARM_SERCLK_EN
  result = MEMORY[0x82000008];
  MEMORY[0x82000008] = 0;                       // config channel priority
  return result;
}

//----- (FFFF12F6) --------------------------------------------------------
signed int disable_keypad()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x87000010] = 0xFFF;                   // Keypad interrupt clear
  MEMORY[0x8B000008] &= 0xFBFFFEFF;             // disable keypad clocks
  return result;
}

//----- (FFFF1310) --------------------------------------------------------
int get_timer_tick()
{
  return MEMORY[0x87003004];
}

//----- (FFFF131C) --------------------------------------------------------
signed int __fastcall ADI_Analogdie_reg_write(unsigned int addr, int data)
{
  int timer_tick; // r0
  int v5; // r3

  get_timer_tick();
  while ( (MEMORY[0x8200002C] & 0x400) == 0 )
  {
    timer_tick = get_timer_tick();
    if ( (unsigned int)(timer_tick - v5) >= 0xA )
      return -1;
  }
  *(_DWORD *)addr = data;
  return 0;
}
// FFFF1336: variable 'v5' is possibly undefined

//----- (FFFF1348) --------------------------------------------------------
signed int __fastcall ADI_Analogdie_reg_read(unsigned int addr)
{
  int timer_tick; // r4
  int v2; // r3

  MEMORY[0x82000024] = addr;
  timer_tick = get_timer_tick();
  do
  {
    if ( (unsigned int)(get_timer_tick() - timer_tick) >= 0xA )
      return -1;
  }
  while ( v2 < 0 );
  return (unsigned __int16)v2;
}
// FFFF136A: variable 'v2' is possibly undefined

//----- (FFFF1370) --------------------------------------------------------
int clock_init()
{
  int result; // r0

  result = ADI_Analogdie_reg_read(0x82000600);
  if ( result != -1 )
  {
    ADI_Analogdie_reg_write(0x82000600, (unsigned __int16)result | 0x202);// ADI_AGEN set bit[1] bit[9]
    return 0;
  }
  return result;
}

//----- (FFFF1390) --------------------------------------------------------
int __fastcall trace_write(int result)
{
  g_TraceValue |= result;
  return result;
}
// 40006000: using guessed type int g_TraceValue;

//----- (FFFF139A) --------------------------------------------------------
int platform_init()
{
  mpll_enable();
  chip_pin_init();
  timer_enable();
  uart_init();
  ADI_init();
  clock_init();
  keypad_init();
  return trace_write(0x20000);
}

//----- (FFFF13C2) --------------------------------------------------------
void __cdecl sleep(unsigned int a1)
{
  unsigned int timer_tick; // r0
  unsigned int v2; // r3

  get_timer_tick();
  do
    timer_tick = get_timer_tick();
  while ( timer_tick < v2 );
}
// FFFF13D2: variable 'v2' is possibly undefined

//----- (FFFF13D6) --------------------------------------------------------
BOOL read_test_mode()
{
  return (MEMORY[0x20900218] & 0x80) != 0;      // BIT_FUNC_TEST_MODE
}

//----- (FFFF13E6) --------------------------------------------------------
BOOL read_usb_dload_en()
{
  return (MEMORY[0x20900218] & 4) == 0;         // BIT_USB_DLOAD_EN
                                                // 0 - enabled, 1 - disabled
}

//----- (FFFF13F6) --------------------------------------------------------
signed int sub_FFFF13F6()
{
  signed int result; // r0

  result = MEMORY[0x8B00001C] << 31;
  if ( MEMORY[0x8B00001C] << 31 )
    return 1;
  return result;
}

//----- (FFFF1404) --------------------------------------------------------
int CheckSecureBootEnable()
{
  int result; // r0
  int v1; // r4

  result = sub_FFFF13F6();
  if ( result )
  {
    efuse_parameter_config_1();
    v1 = sub_FFFF33FA(efuse_hash_data);
    efuse_parameter_config_2();
    if ( v1 )
    {
      trace_write(0x40000);
    }
    else if ( efuse_hash_data[0] >= 0 )
    {
      return 0;
    }
    return 1;
  }
  return result;
}
// 40006658: using guessed type int efuse_hash_data[];

//----- (FFFF143A) --------------------------------------------------------
signed int __fastcall usb_ldo_ctrl(int a1)
{
  signed int result; // r0
  int v3; // r1

  result = ADI_Analogdie_reg_read(0x82000610);  // ANA_LDO_PD_CTL0
  if ( result != -1 )
  {
    if ( a1 )
      v3 = result & 0xFFFC | 2;
    else
      v3 = result & 0xFFFC | 1;
    return ADI_Analogdie_reg_write(0x82000610, v3);
  }
  return result;
}

//----- (FFFF146C) --------------------------------------------------------
signed int usb_ref_clock_init()
{
  signed int result; // r0

  result = 0x2090020C;
  MEMORY[0x2090020C] &= ~1u;                    // clear AHB_AHB_CTL3.BIT_CLK_USB_REF_SEL
  MEMORY[0x2090020C] |= 0x40u;                  // AHB_AHB_CTL3.BIT_CLK_USB_REF_EN
  return result;
}

//----- (FFFF1480) --------------------------------------------------------
signed int __fastcall HashVerify(int *a1, unsigned int a2)
{
  unsigned int i; // r0

  MD5Init(soft_hash_data);
  MD5Final(a1, a2, soft_hash_data);
  for ( i = 0; i < 4; ++i )
  {
    soft_hash_data[i] &= ~0x80000000;
    efuse_hash_data[i] &= ~0x80000000;
  }
  if ( soft_hash_data[0] == efuse_hash_data[0]
    && dword_4000666C == dword_4000665C
    && dword_40006670 == dword_40006660
    && dword_40006674 == dword_40006664 )
  {
    trace_write(0x8000);
    return 1;
  }
  else
  {
    trace_write(0x10000);
    return 0;
  }
}
// 40006658: using guessed type int efuse_hash_data[];
// 4000665C: using guessed type int dword_4000665C;
// 40006660: using guessed type int dword_40006660;
// 40006664: using guessed type int dword_40006664;
// 40006668: using guessed type int soft_hash_data[];
// 4000666C: using guessed type int dword_4000666C;
// 40006670: using guessed type int dword_40006670;
// 40006674: using guessed type int dword_40006674;

//----- (FFFF14F8) --------------------------------------------------------
int read_usb_hisgspeed_sel()
{
  int result; // r0

  result = MEMORY[0x20900218] & 2;              // BIT_USB_HIGHSPEED_SEL
  if ( (MEMORY[0x20900218] & 2) != 0 )
    return 1;
  return result;
}

//----- (FFFF1506) --------------------------------------------------------
BOOL read_arm_boot_md0()
{
  return (MEMORY[0x20900218] & 8) == 0;         // BIT_ARM_BOOT_MD0
}

//----- (FFFF1516) --------------------------------------------------------
uint32 __fastcall sub_FFFF1516(int a1)
{
  g_TraceValue |= a1;
  return uart_trace((unsigned __int8 *)&g_TraceValue, 4);
}
// 40006000: using guessed type int g_TraceValue;

//----- (FFFF1526) --------------------------------------------------------
BOOL read_arm_boot_md1()
{
  return (MEMORY[0x20900218] & 0x10) == 0;      // BIT_ARM_BOOT_MD1 
                                                // 0 - emmc, 1 - nand
}

//----- (FFFF1536) --------------------------------------------------------
BOOL read_arm_boot_md3()
{
  return (MEMORY[0x20900218] & 0x40) != 0;      // BIT_ARM_BOOT_MD3
}

//----- (FFFF1546) --------------------------------------------------------
BOOL read_arm_boot_md2()
{
  return (MEMORY[0x20900218] & 0x20) == 0;      // BIT_ARM_BOOT_MD2
}

//----- (FFFF1556) --------------------------------------------------------
int __fastcall mmc_ldo_ctrl(int slot_number, int onOrOff, int volt_level)
{
  unsigned int v5; // r0
  unsigned __int16 v6; // r0
  unsigned int v7; // r5
  unsigned int v8; // r0
  unsigned __int16 v9; // r0
  unsigned int v11; // r0
  unsigned __int16 v12; // r0
  unsigned int v13; // r0

  if ( slot_number )                            // LDO_LDO_SDIO1
  {
    v5 = ADI_Analogdie_reg_read(0x82000624) & 0xFFFF0FFF;// ANA_LDO_VCTL3
    if ( volt_level )
      v6 = v5 | 0x9000;
    else
      v6 = v5 | 0x5000;
    ADI_Analogdie_reg_write(0x82000624, v6);
    v7 = 0x82000614;
    v8 = ADI_Analogdie_reg_read(0x82000614) & 0xFFFFFFFC;// ANA_LDO_PD_CTL1
    if ( onOrOff == 1 )
      v9 = v8 | 2;                              // BIT_1 
    else
      v9 = v8 | 1;                              // BIT_0
  }
  else                                          // LDO_LDO_SDIO0
  {
    v11 = ADI_Analogdie_reg_read(0x8200061C) & 0xFFFF0FFF;// ANA_LDO_VCTL1
    if ( volt_level )
      v12 = v11 | 0x9000;
    else
      v12 = v11 | 0x5000;
    ADI_Analogdie_reg_write(0x8200061C, v12);
    v7 = 0x82000610;
    v13 = ADI_Analogdie_reg_read(0x82000610) & 0xFFFFFFF3;// ANA_LDO_PD_CTL0
    if ( onOrOff == 1 )
      v9 = v13 | 8;                             // BIT_3
    else
      v9 = v13 | 4;                             // BIT_2
  }
  return ADI_Analogdie_reg_write(v7, v9);
}

//----- (FFFF1610) --------------------------------------------------------
signed int emmc_setup_pin()
{
  unsigned int i; // r0
  unsigned int v1; // r2
  signed int result; // r0

  for ( i = 0; i < 8; ++i )
  {
    v1 = i;
    *(_DWORD *)(4 * v1 - 0x73FFFE84) |= 0x30u;
  }
  result = 0x8C000408;
  MEMORY[0x8C000408] |= 0x30u;                  // NFCEN1 set to pin mode 3, GPIO71
  return result;
}

//----- (FFFF163A) --------------------------------------------------------
int __fastcall sim2_ldo_ctrl(int onOrOff)
{
  __int16 v2; // r0
  unsigned int v3; // r0
  unsigned __int16 v4; // r0

  v2 = ADI_Analogdie_reg_read(0x82000628);      // ANA_LDO_VCTL4
  ADI_Analogdie_reg_write(0x82000628, v2 & 0xF0FF | 0x900);
  v3 = ADI_Analogdie_reg_read(0x82000614) & 0xFFFFFF3F;
  if ( onOrOff == 1 )
    v4 = v3 | 0x80;
  else
    v4 = v3 | 0x40;
  return ADI_Analogdie_reg_write(0x82000614, v4);
}
/* Orphan comments:
ANA_LDO_PD_CTL1
*/

//----- (FFFF1688) --------------------------------------------------------
int __fastcall memset(int result, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v4; // r1
  int v5; // r12
  unsigned __int8 *v6; // r0

  v4 = a3;
  if ( a3 < 4 )
  {
    if ( __CFSHL__(a3, 31) )
    {
      *(_BYTE *)result = a2;
      v6 = (unsigned __int8 *)(result + 1);
      *v6 = a2;
      result = (int)(v6 + 1);
    }
    if ( (a3 & 1) != 0 )
      *(_BYTE *)result++ = a2;
  }
  else
  {
    if ( (result & 3) != 0 )
    {
      v5 = 4 - (result & 3);
      if ( v5 != 2 )
        *(_BYTE *)result++ = a2;
      if ( v5 >= 2 )
      {
        *(_WORD *)result = a2 | (a2 << 8);
        result += 2;
      }
      v4 = a3 - v5;
    }
    return (int)memset_w((_DWORD *)result, v4, a2 | (a2 << 8) | ((a2 | (a2 << 8)) << 16));
  }
  return result;
}

//----- (FFFF1692) --------------------------------------------------------
int __fastcall SPL_CheckSum(const unsigned int *src, int len)
{
  unsigned int sum; // r2
  int v3; // r3
  int v4; // t1

  sum = 0;
  while ( len > 3 )
  {
    v3 = *src++;
    len -= 4;
    sum += v3;
  }
  if ( (len & 2) != 0 )
  {
    v4 = *(unsigned __int16 *)src;
    src = (const unsigned int *)((char *)src + 2);
    sum += v4;
  }
  if ( len << 31 )
    sum += *(unsigned __int8 *)src;
  return (unsigned __int16)~(HIWORD(sum) + sum + ((unsigned int)(HIWORD(sum) + (unsigned __int16)sum) >> 16));
}

//----- (FFFF16C4) --------------------------------------------------------
signed int nand_stuffs_1()
{
  unsigned int v0; // r0
  unsigned int v1; // r2
  unsigned int v2; // r1
  _DWORD *v3; // r1
  signed int result; // r0

  v0 = 0;
  MEMORY[0x20900200] |= 0x100u;
  MEMORY[0x20900210] |= 0x20u;
  do
    ++v0;
  while ( v0 < 0x64 );
  v1 = 0;
  MEMORY[0x20900210] &= ~0x20u;
  MEMORY[0x8C000140] &= ~0x100u;                // pin multiplex
  MEMORY[0x8C000140] |= 0x200u;
  MEMORY[0x8C000144] |= 0x280u;
  MEMORY[0x8C000144] &= ~0x100u;
  do
  {
    v2 = v1++;
    v3 = (_DWORD *)(4 * v2 - 1946156728);
    *v3 |= 0x200u;
    *v3 &= ~0x100u;
  }
  while ( v1 < 0x15 );
  result = 0xFFFF3CFF;
  MEMORY[0x60000010] = 0xFFFF3CFF;
  return result;
}

//----- (FFFF1742) --------------------------------------------------------
// Disable NAND after failed to boot
signed int disable_nfc()
{
  int v0; // r1
  signed int result; // r0

  v0 = 0;
  MEMORY[0x20900210] |= 0x20u;                  // Set or reset bit[5] of 0x2090_0210 to reset NFC module 
  do
    ++v0;
  while ( v0 < 100 );
  result = 0x20900200;
  MEMORY[0x20900210] &= ~0x20u;                 // 0x2090_0210 bit[5] = 0
  MEMORY[0x20900200] &= ~0x100u;                // 0x2090_0200 bit[8] = 0 disable NFC clock
  return result;
}

//----- (FFFF176E) --------------------------------------------------------
signed int sub_FFFF176E()
{
  int timer_tick; // r5
  int v1; // r6
  int v2; // r0
  int v3; // r5

  MEMORY[0x60000060] = 0x1FA01FA;
  MEMORY[0x60000004] |= 0x8000u;
  MEMORY[0x60000000] = 0x8000FFFD;
  timer_tick = get_timer_tick();
  while ( (unsigned int)(get_timer_tick() - timer_tick) < 2 )
    ;
  v1 = MEMORY[0x60000004];
  get_timer_tick();
  v2 = get_timer_tick();
  v3 = v2;
  while ( !(v1 << 31) && (unsigned int)(v2 - v3) < 5 )
  {
    v1 = MEMORY[0x60000004];
    v2 = get_timer_tick();
  }
  MEMORY[0x60000004] &= ~0x8000u;
  if ( (unsigned int)(v2 - v3) >= 5 )
    return 2;
  else
    return 0;
}

//----- (FFFF17C8) --------------------------------------------------------
int __fastcall sub_FFFF17C8(int a1)
{
  if ( ((*(_DWORD *)((a1 & 0xFFFFFFFC) + 1610612800) >> ((8 * a1) & 0x1F)) & 0x1F) == 31 )
    return 5;
  else
    return 0;
}

//----- (FFFF17EA) --------------------------------------------------------
int __fastcall sub_FFFF17EA(unsigned __int8 *a1)
{
  int v1; // r1

  v1 = *a1 * *((unsigned __int16 *)a1 + 5);
  switch ( v1 )
  {
    case 512:
      return 3;
    case 2048:
      return 8;
    case 4096:
      return 16;
  }
  return 32;
}

//----- (FFFF1812) --------------------------------------------------------
int __fastcall sub_FFFF1812(unsigned __int8 *a1, int a2)
{
  unsigned int v4; // r5
  char v5; // r7
  int timer_tick; // r0
  int v7; // r6
  int result; // r0
  unsigned int i; // r5

  v4 = sub_FFFF17EA(a1);
  if ( a1[3] && !a1[4] )
    MEMORY[0x60000060] = 2 * a2;
  else
    MEMORY[0x60000060] = a2;
  MEMORY[0x60000080] = -1;
  MEMORY[0x60000024] = 2031616;
  MEMORY[0x60000004] = ((a1[2] << 12) - 12288) | ((*a1 * a1[6] - 1) << 16) | (a1[1] << 14) | (a1[3] << 9) | (32 * a1[4]);
  MEMORY[0x60000030] = (((int)reset >> 8) + (a1[7] << 8)) | ((unsigned int)reset + 0x10000 * a1[6]) | (a1[5] << 24) | (16 * a1[8]) | 6;
  MEMORY[0x60000034] = *((unsigned __int16 *)a1 + 5) - 1;
  MEMORY[0x60000000] = (int)reset >> 8 << 23;
  v5 = 0;
  timer_tick = get_timer_tick();
  v7 = timer_tick;
  while ( (v5 & 2) == 0 && timer_tick - v7 < v4 )
  {
    v5 = MEMORY[0x60000024];
    timer_tick = get_timer_tick();
  }
  MEMORY[0x60000030] &= ~2u;
  if ( timer_tick - v7 >= v4 )
    return 2;
  for ( i = 0; *a1 > i; ++i )
  {
    result = sub_FFFF17C8(i);
    if ( result == 5 )
      return result;
  }
  return 0;
}

//----- (FFFF18EC) --------------------------------------------------------
int __fastcall sub_FFFF18EC(unsigned __int16 *a1)
{
  char v1; // r6
  int timer_tick; // r0
  int v3; // r5
  unsigned int v4; // r0

  MEMORY[0x60000024] = 2031616;
  MEMORY[0x60000034] = *((_DWORD *)a1 + 1) - 1;
  MEMORY[0x60000030] = ((unsigned int)reset + 0x10000 * *a1) | (a1[1] << 24) | 0x65;
  v1 = 0;
  timer_tick = get_timer_tick();
  v3 = timer_tick;
  while ( 1 )
  {
    v4 = timer_tick - v3;
    if ( (v1 & 2) != 0 )
      break;
    if ( v4 >= 0x10 )
      return 2;
    v1 = MEMORY[0x60000024];
    timer_tick = get_timer_tick();
  }
  if ( v4 >= 0x10 )
    return 2;
  return sub_FFFF17C8(0);
}

//----- (FFFF1940) --------------------------------------------------------
signed int __fastcall sub_FFFF1940(unsigned __int8 *a1, int a2)
{
  int v2; // r6
  int timer_tick; // r0
  int v4; // r5
  unsigned int v5; // r0

  if ( a1[3] && !a1[4] )
  {
    MEMORY[0x60000060] = 2 * a2;
    MEMORY[0x60000080] = 2 * a2 + 511;
  }
  else
  {
    MEMORY[0x60000060] = a2;
    MEMORY[0x60000080] = a2 + 511;
  }
  MEMORY[0x60000024] = 0x1F0000;
  MEMORY[0x60000004] = (a1[1] << 14) | (a1[2] << 12) | (a1[3] << 9) | (32 * a1[4]);
  MEMORY[0x60000000] = 0x80000000;
  v2 = 0x1F0000;
  timer_tick = get_timer_tick();
  v4 = timer_tick;
  while ( 1 )
  {
    v5 = timer_tick - v4;
    if ( v2 << 31 )
      break;
    if ( v5 >= 0x10 )
      return 2;
    v2 = MEMORY[0x60000024];
    timer_tick = get_timer_tick();
  }
  if ( v5 >= 0x10 )
    return 2;
  return 0;
}

//----- (FFFF19D4) --------------------------------------------------------
struct UART_REG *__fastcall uart_send_reply(unsigned int a1)
{
  unsigned __int16 v1; // r1
  struct BM_PACKAGE *v2; // r0

  v1 = asm_rev16(a1);
  v2 = packet_buf;
  packet_buf->header.type = v1;
  v2->header.len = 0;
  return uart_send((unsigned __int8 *)v2, 6);
}

//----- (FFFF19F0) --------------------------------------------------------
void __fastcall __noreturn uart_download_main(int a1, int a2, unsigned __int16 *a3, int a4)
{
  signed int ret; // r0
  unsigned int v5; // r0
  unsigned __int16 *v6; // [sp+0h] [bp-10h] BYREF
  int v7; // [sp+4h] [bp-Ch] BYREF

  v6 = a3;
  v7 = a4;
  while ( 1 )
  {
    ret = read_packet_from_uart(&v6, &v7);
    if ( ret == 0x8F )                          // BSL_PHONE_SUCCEED
                                                // Read packet from uart succeeded (no CRC error)
    {
      v5 = asm_rev16(*v6);
      uart_dl_ops[v5](v6, v7);
    }
    else
    {
      uart_send_reply(ret);
      memset((int)&word_40007E8C, 0, 0x18u);
    }
  }
}
// 40007E8C: using guessed type __int16 word_40007E8C;

//----- (FFFF1A7C) --------------------------------------------------------
int __fastcall detect_uart_download(UART_REG *a1, int *a2, _BYTE *a3)
{
  int result; // r0

  if ( (unsigned __int8)a1->UART_STS1 )
  {
    if ( a1->UART_RXD == 0x7E )                 // 0x7E received
      result = *a2 + 1;
    else
      result = 0;
    *a2 = result;
  }
  else
  {
    result = 1;
    *a3 = 1;
  }
  return result;
}

//----- (FFFF1A9C) --------------------------------------------------------
unsigned int __fastcall check_uart_download(int a1)
{
  unsigned int result; // r0
  char v3[4]; // [sp+4h] [bp-3Ch] BYREF
  char v4[4]; // [sp+8h] [bp-38h] BYREF
  int timer_tick; // [sp+Ch] [bp-34h]
  unsigned int v6; // [sp+10h] [bp-30h] BYREF
  int v7[11]; // [sp+14h] [bp-2Ch] BYREF

  v3[0] = 0;
  v4[0] = 0;
  v6 = 0;
  v7[0] = 0;
  timer_tick = get_timer_tick();
  do
  {
    detect_uart_download((UART_REG *)0x84000000, v7, v4);
    detect_uart_download((UART_REG *)0x83000000, (int *)&v6, v3);
    if ( v7[0] >= 3u )
    {
LABEL_3:
      *(_BYTE *)(a1 + 1) = 1;
      result = 0x6A00;
      uart_selected = (struct UART_REG *)0x84000000;
LABEL_6:
      MEMORY[0x8B000020] = result;
      return result;
    }
    if ( v6 >= 3 )
    {
      *(_BYTE *)(a1 + 1) = 1;
      result = 0x7A00;
      uart_selected = (struct UART_REG *)0x83000000;
      goto LABEL_6;
    }
  }
  while ( (!v4[0] || !v3[0]) && (unsigned int)(get_timer_tick() - timer_tick) <= 0x78 );
  while ( 1 )
  {
    result = get_timer_tick() - dword_40006010;
    if ( result > 0x78 )
      return result;
    detect_uart_download((UART_REG *)0x84000000, v7, v4);
    detect_uart_download((UART_REG *)0x83000000, (int *)&v6, v3);
    if ( v7[0] >= 3u )
      goto LABEL_3;
    result = v6;
    if ( v6 >= 3 )
    {
      *(_BYTE *)(a1 + 1) = 1;
      uart_selected = (struct UART_REG *)0x83000000;
      MEMORY[0x8B000020] = 0x7A00;
      return result;
    }
  }
}
// 40006010: using guessed type int dword_40006010;

//----- (FFFF1B5C) --------------------------------------------------------
signed int __fastcall sub_FFFF1B5C(int a1)
{
  *(_BYTE *)a1 = MEMORY[0x60002048];
  *(_BYTE *)(a1 + 1) = MEMORY[0x60002030];
  *(_BYTE *)(a1 + 2) = MEMORY[0x60002028];
  *(_BYTE *)(a1 + 3) = MEMORY[0x60002024];
  *(_BYTE *)(a1 + 4) = MEMORY[0x6000202C];
  *(_BYTE *)(a1 + 5) = MEMORY[0x60002040];
  *(_BYTE *)(a1 + 6) = MEMORY[0x60002038];
  *(_BYTE *)(a1 + 7) = MEMORY[0x60002048];
  *(_BYTE *)(a1 + 8) = MEMORY[0x6000203C];
  *(_WORD *)(a1 + 10) = MEMORY[0x60002044];
  return 1;
}

//----- (FFFF1B8C) --------------------------------------------------------
int __fastcall maybe_nand_read(int a1, int a2, int a3, unsigned int a4)
{
  int v5[4]; // [sp+0h] [bp-10h] BYREF

  j_j___aeabi_memcpy(0x60004000, 0x6000204C, 44, a4);
  memset(0x6000204C, 0, 0x2Cu);
  v5[0] = 44;
  v5[1] = 512;
  return sub_FFFF18EC((unsigned __int16 *)v5);
}

//----- (FFFF1BCC) --------------------------------------------------------
int __fastcall sub_FFFF1BCC(_BYTE *a1, int a2, unsigned int a3)
{
  int v3; // r4
  unsigned int v6; // r6
  int result; // r0
  _BYTE *v8; // r4
  unsigned int v9; // r5
  signed int v10; // r0
  int v11; // r1
  int v12; // r2
  unsigned int v13; // r3

  v3 = 0;
  trace_write(16);
  v6 = 0;
LABEL_8:
  if ( v6 < a3 )
  {
    nand_stuffs_1();
    result = sub_FFFF176E();
    if ( !result )
    {
      v8 = (_BYTE *)(5 * v6 + a2);
      memset((int)a1, 0, 0xCu);
      v9 = 0;
      a1[2] = v8[3];
      a1[1] = v8[2];
      a1[3] = v8[4];
      a1[4] = v8[1];
      while ( 1 )
      {
        v10 = sub_FFFF1940(a1, v9);
        v3 = v10;
        if ( v10 )
        {
          if ( v10 == 2 )
            goto LABEL_7;
        }
        else
        {
          v3 = maybe_nand_read(0, v11, v12, v13);
          if ( !v3
            && MEMORY[0x60002034] == 0xAA55A5A5
            && MEMORY[0x60002020] == SPL_CheckSum((const unsigned int *)0x60002024, 476)
            && sub_FFFF1B5C((int)a1) )
          {
            trace_write(32);
            return 0;
          }
        }
        v9 += 0x4000;
        if ( v9 >= 0xC000 )
        {
LABEL_7:
          ++v6;
          goto LABEL_8;
        }
      }
    }
  }
  else
  {
    trace_write(64);
    return v3;
  }
  return result;
}
// FFFF1C4A: variable 'v11' is possibly undefined
// FFFF1C4A: variable 'v12' is possibly undefined
// FFFF1C4A: variable 'v13' is possibly undefined

//----- (FFFF1C84) --------------------------------------------------------
int __fastcall sub_FFFF1C84(unsigned __int8 *a1, int a2, int a3)
{
  unsigned int v4; // r5
  int v5; // r7
  char *v6; // r6
  size_t v8; // r4
  int result; // r0

  v4 = 0;
  v5 = a2 << 14;
  v6 = (_BYTE *)dword_40000000;
  v8 = *((unsigned __int16 *)a1 + 5) * *a1;
  while ( 1 )
  {
    result = sub_FFFF1812(a1, v5);
    if ( result == 2 || a3 && result == 5 )
      break;
    qmemcpy(v6, (const void *)0x60002000, v8);
    v4 += v8;
    v5 += v8;
    v6 += v8;
    if ( v4 >= 0x4000 )
      return 0;
  }
  return result;
}
// 40000000: using guessed type _DWORD dword_40000000[8];

//----- (FFFF1CD8) --------------------------------------------------------
signed int __fastcall nand_stuffs_2(unsigned __int8 *a1)
{
  unsigned int v1; // r4
  signed int result; // r0
  int v4; // r0
  int v5; // r5
  int v6; // r0

  v1 = 0;
  trace_write(128);
  nand_stuffs_1();
  result = sub_FFFF176E();
  if ( result != 2 )
  {
    while ( 1 )
    {
      v4 = sub_FFFF1C84(a1, v1, 1);
      v5 = v4;
      if ( !v4 )
        break;
      if ( v4 == 2 )
      {
        v6 = 256;
        goto LABEL_8;
      }
      if ( v4 == 5 )
        trace_write(1024 << v1);
      v1 = (unsigned __int8)(v1 + 1);
      if ( v1 >= 3 )
        return sub_FFFF1C84(a1, 0, 0);
    }
    v6 = 512;
LABEL_8:
    trace_write(v6);
    return v5;
  }
  return result;
}

//----- (FFFF1D74) --------------------------------------------------------
signed int clear_uart_fifo()
{
  signed int result; // r0

  result = 0x83000000;
  while ( MEMORY[0x8400000C] )                  // clear uart1 fifo
    ;
  while ( MEMORY[0x8300000C] )                  // clear uart0 fifo
    ;
  return result;
}

//----- (FFFF1DA0) --------------------------------------------------------
BOOL __fastcall read_spl_from_nand(int a1, int a2, int a3, int a4)
{
  signed int v4; // r4
  char v6[4]; // [sp+0h] [bp-18h] BYREF
  int v7; // [sp+4h] [bp-14h]
  int v8; // [sp+8h] [bp-10h]

  v7 = a3;
  v8 = a4;
  v4 = 1;
  if ( read_arm_boot_md0()
    && (!sub_FFFF1BCC(v6, (int)&unk_40006020, 0xCu) || !sub_FFFF1BCC(v6, (int)&unk_4000605C, 0x24u)) )
  {
    v4 = nand_stuffs_2((unsigned __int8 *)v6);
    if ( !v4 )
      return 1;
  }
  if ( !sub_FFFF1BCC(v6, (int)&unk_4000605C, 0x24u) || !sub_FFFF1BCC(v6, (int)&unk_40006020, 0xCu) )
    v4 = nand_stuffs_2((unsigned __int8 *)v6);
  return !v4;
}

//----- (FFFF1E1C) --------------------------------------------------------
int __cdecl main()
{
  unsigned __int16 v0; // r1
  struct BM_PACKAGE *v1; // r0
  unsigned int v2; // r3
  struct UART_REG *v3; // r0
  int v4; // r1
  unsigned __int16 *v5; // r2
  int v6; // r3
  unsigned int uboot_spl_read_size; // r0
  unsigned int boot_from_iram; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int spl_read_success; // r5
  unsigned int v14; // r0
  int v15; // r4
  int v16; // r6
  int secboot_enabled; // r0 MAPDST
  int is_highspeed; // r0
  int uart_download; // [sp+0h] [bp-8h] BYREF

  uart_download = 0;
  MEMORY[0x20000000] &= ~0x1000u;               // EMC request timeout enable
  boot_from_iram = read_test_mode();            // Test mode
  if ( boot_from_iram )
  {
    trace_write(1);
    jump_to(0);
    while ( 1 )
      ;
  }
  do
    ++boot_from_iram;
  while ( boot_from_iram < 0xA );
  platform_init();
  clear_uart_fifo();
  memset((int)&word_40007E8C, 0, 0x18u);
  byte_40007E90 = 0;
  packet_buf = 0;
  dword_4000601C = 0;
  dword_40006010 = get_timer_tick();
  if ( read_arm_boot_md1() )
    spl_read_success = (unsigned __int8)read_spl_from_emmc();
  else
    spl_read_success = read_spl_from_nand(0, v10, v11, v12);
  uart_selected = (struct UART_REG *)0x83000000;
  v14 = get_timer_tick() - dword_40006010;
  if ( v14 < 0x14 )
    sleep(20 - v14);
  v15 = MEMORY[0x87000008] & 1;                 // detect keypad pressed
  v16 = MEMORY[0x8700002C] & 0x77;              // 0x8700002C keypad key status, 0x77 == volume down pressed
  if ( !read_usb_dload_en() )
  {
    if ( !v15 || v16 )                          // key is not pressed
    {
      disable_keypad();
      check_uart_download((int)&uart_download); // then check uart
      goto LABEL_12;
    }
    disable_keypad();
  }
  is_highspeed = read_usb_hisgspeed_sel();
  usb_dload_start(is_highspeed);
LABEL_12:
  if ( BYTE1(uart_download) != 1 )              // if not going to enter uart download mode
  {
    secboot_enabled = CheckSecureBootEnable();
    if ( spl_read_success != 1 )
    {
      disable_nfc();
      while ( 1 )
        ;
    }
    trace_write(0x2000);
    if ( read_arm_boot_md1() )
      uboot_spl_read_size = 0x6000;             // 24kb
    else
      uboot_spl_read_size = 0x4000;             // 16kb
    if ( !secboot_enabled || HashVerify(dword_40000000, uboot_spl_read_size >> 2) )
    {
      jump_to(0x40000000);                      // Jump to SPL !
      while ( 1 )
        ;
    }
    while ( 1 )
      ;
  }
  disable_keypad();
  trace_write(8);
  packet_buf = (struct BM_PACKAGE *)&INIT_STACK;// Enter uart download mode
  dword_4000601C = (int)&unk_40007A8C;
  memset((int)&uart_dl_status, 0, 0x20u);
  check_uart_baudrate();
  packet_buf->header.type = asm_rev16(0x81u);   // BSL_REP_VER
  v0 = asm_rev16(6u);
  v1 = packet_buf;
  packet_buf->header.len = v0;
  j_j___aeabi_memcpy((int)&v1->data, (int)"SPRD3", 6, v2);
  v3 = uart_send((unsigned __int8 *)packet_buf, 12);
  uart_download_main((int)v3, v4, v5, v6);
}
// FFFF1ECA: variable 'v10' is possibly undefined
// FFFF1ECA: variable 'v11' is possibly undefined
// FFFF1ECA: variable 'v12' is possibly undefined
// FFFF1A68: variable 'v2' is possibly undefined
// FFFF1A74: variable 'v4' is possibly undefined
// FFFF1A74: variable 'v5' is possibly undefined
// FFFF1A74: variable 'v6' is possibly undefined
// 40000000: using guessed type _DWORD dword_40000000[8];
// 40006010: using guessed type int dword_40006010;
// 4000601C: using guessed type int dword_4000601C;
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007EA4: using guessed type int uart_dl_status;

//----- (FFFF1EF0) --------------------------------------------------------
int dl_uart_connect()
{
  if ( byte_40007E90 != 1 )
  {
    uart_send_reply(0x80u);                     // BSL_REP_ACK
    byte_40007E90 = 1;
  }
  return memset((int)&word_40007E8C, 0, 0x18u);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;

//----- (FFFF1F14) --------------------------------------------------------
struct UART_REG *__fastcall dl_uart_start_data(int a1)
{
  unsigned int v2; // r4
  unsigned int v3; // r0

  v2 = sub_FFFF23C4(*(_DWORD *)(a1 + 4));
  v3 = sub_FFFF23C4(*(_DWORD *)(a1 + 8));
  dword_40007E9C = v2;
  dword_40007EA0 = v2;
  dword_40007E94 = v3;
  return uart_send_reply(0x80u);
}
// 40007E94: using guessed type int dword_40007E94;
// 40007E9C: using guessed type int dword_40007E9C;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF1F38) --------------------------------------------------------
struct UART_REG *__fastcall dl_uart_midst_data(int a1)
{
  int v2; // r6
  unsigned int v3; // r3

  v2 = asm_rev16(*(unsigned __int16 *)(a1 + 2));
  j_j___aeabi_memcpy(dword_40007EA0, a1 + 4, v2, v3);
  dword_40007EA0 += v2;
  dword_40007E98 += v2;
  return uart_send_reply(0x80u);
}
// FFFF1F4C: variable 'v3' is possibly undefined
// 40007E98: using guessed type int dword_40007E98;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF1F64) --------------------------------------------------------
struct UART_REG *dl_uart_end_data()
{
  if ( dword_40007E98 == dword_40007E94 )
  {
    word_40007E8C = 0x8F;                       // BSL_PHONE_SUCCEED
    return uart_send_reply(0x80u);
  }
  else
  {
    byte_40007E90 = 5;
    return uart_send_reply(0x8Bu);              // BSL_REP_VERIFY_ERROR
  }
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007E94: using guessed type int dword_40007E94;
// 40007E98: using guessed type int dword_40007E98;

//----- (FFFF1F80) --------------------------------------------------------
int dl_uart_exec()
{
  uart_send_reply(0x80u);                       // BSL_REP_ACK
  return jump_to(dword_40007E9C);
}
// 40007E9C: using guessed type int dword_40007E9C;

//----- (FFFF1F94) --------------------------------------------------------
// Version packet size is 6
int get_ver_pkt_size()
{
  return 6;
}

//----- (FFFF1FA0) --------------------------------------------------------
int __fastcall sub_FFFF1FA0(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  unsigned int v4; // r2
  bool v5; // nf

  result = 0;
  while ( a2-- != 0 )
  {
    v4 = 0x80;
    do
    {
      v5 = (result & 0x8000) != 0;
      result = (unsigned __int16)(2 * result);
      if ( v5 )
        result ^= 0x1021u;
      if ( (*a1 & (unsigned __int8)v4) != 0 )
        result ^= 0x1021u;
      v4 >>= 1;
    }
    while ( v4 );
    ++a1;
  }
  return result;
}

//----- (FFFF1FD0) --------------------------------------------------------
// attributes: thunk
void __fastcall j___aeabi_memcpy(void *a1, const void *a2, size_t a3)
{
  qmemcpy(a1, a2, a3);
}

//----- (FFFF21AC) --------------------------------------------------------
void __fastcall sub_FFFF21AC(unsigned int a1, unsigned int a2)
{
  if ( (a2 & 0x80000000) != 0 )
    a2 = -a2;
  if ( (a1 & 0x80000000) != 0 )
    a1 = -a1;
  if ( a1 >> 4 >= a2 )
  {
    if ( a1 >> 8 >= a2 )
      JUMPOUT(0xFFFF21CC);
    JUMPOUT(0xFFFF220C);
  }
  JUMPOUT(0xFFFF223C);
}
// FFFF21C8: control flows out of bounds to FFFF21CC
// FFFF21C0: control flows out of bounds to FFFF223C
// FFFF21C8: control flows out of bounds to FFFF220C

//----- (FFFF232A) --------------------------------------------------------
void *sub_FFFF232A()
{
  void *result; // r0
  _DWORD *v1; // [sp-8h] [bp-8h]

  v1 = sub_FFFF2380();
  result = sub_FFFF0038();
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0;
  v1[9] = 0;
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[13] = 0;
  v1[14] = 0;
  v1[15] = 0;
  return result;
}

//----- (FFFF2380) --------------------------------------------------------
void *sub_FFFF2380()
{
  return &unk_40007EC4;
}

//----- (FFFF2388) --------------------------------------------------------
void *sub_FFFF2388()
{
  return &unk_40007EC8;
}

//----- (FFFF23B4) --------------------------------------------------------
// attributes: thunk
int __fastcall jump_to(int a1)
{
  return jump_to(a1);
}

//----- (FFFF23BC) --------------------------------------------------------
// REV16 converts 16-bit big-endian data into little-endian data or 16-bit little-endian data into big-endian data.
unsigned int __fastcall asm_rev16(unsigned int a1)
{
  return __rev16(a1);
}

//----- (FFFF23C4) --------------------------------------------------------
unsigned int __fastcall sub_FFFF23C4(int a1)
{
  return __ROR4__(a1, 8) ^ (((a1 ^ __ROR4__(a1, 16)) & 0xFF00FFFF) >> 8);
}

//----- (FFFF2484) --------------------------------------------------------
void __fastcall sub_FFFF2484(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  int *v5; // r4
  unsigned int *v6; // r5
  int i; // r0
  int j; // r6
  _DWORD v12[74]; // [sp+0h] [bp-128h] BYREF

  v5 = v12;
  v6 = a1;
  for ( i = 0; i < 65; ++i )
    v12[i] = 0;
  for ( j = 0; j < 32; ++j )
  {
    sub_FFFF34A8(v5, a2, *v6++);
    sub_FFFF34A8(v5, a3, *v5 * a4);
    ++v5;
  }
  if ( !sub_FFFF3460(v5, (int *)a3) )
    v5 -= 32;
  qmemcpy(a1, v5, 0x80u);
}

//----- (FFFF2528) --------------------------------------------------------
void __fastcall sub_FFFF2528(_DWORD *a1, unsigned int *a2, int a3)
{
  int *v4; // r4
  int i; // r0
  int j; // r0
  int k; // r5
  _DWORD v10[72]; // [sp+0h] [bp-120h] BYREF

  v4 = v10;
  for ( i = 32; i < 65; ++i )
    v10[i] = 0;
  for ( j = 0; j < 32; ++j )
    v10[j] = a1[j];
  for ( k = 0; k < 32; ++k )
  {
    sub_FFFF34A8(v4, a2, *v4 * a3);
    ++v4;
  }
  if ( !sub_FFFF3460(v4, (int *)a2) )
    v4 -= 32;
  qmemcpy(a1, v4, 0x80u);
}

//----- (FFFF25C8) --------------------------------------------------------
unsigned int __fastcall sub_FFFF25C8(unsigned int result)
{
  int v1; // r3
  unsigned int v2; // r4
  int v3; // r2
  int v4; // r1

  v1 = 1;
  v2 = result;
  v3 = 1;
  v4 = 0;
  do
  {
    if ( (result & 1) == 0 )
    {
      result += v2;
      v1 |= v3;
    }
    ++v4;
    result >>= 1;
    if ( v4 >= 32 )
      result = v1;
    v3 *= 2;
  }
  while ( v4 < 32 );
  return result;
}

//----- (FFFF2604) --------------------------------------------------------
void __fastcall RSA_ModPower(int result, _DWORD *a2, unsigned int *a3, int a4)
{
  bool v4; // zf
  unsigned int v9; // r4
  int v10; // r8
  int i; // r0
  int j; // r0
  unsigned int v13; // r4
  int k; // r9
  unsigned int v15[40]; // [sp+0h] [bp-A0h] BYREF

  v4 = result == 0;
  if ( result )
    v4 = a2 == 0;
  v9 = 0x80000000;
  if ( !v4 && a3 )
  {
    v10 = sub_FFFF25C8(*a2);
    sub_FFFF2484((_DWORD *)result, a3, a2, v10);
    for ( i = 0; i < 32; ++i )
      v15[i] = *(_DWORD *)(result + 4 * i);
    for ( j = 0; j < 32; ++j )
    {
      if ( (a4 & v9) != 0 )
        break;
      v9 >>= 1;
    }
    v13 = v9 >> 1;
    for ( k = j + 1; k < 32; ++k )
    {
      sub_FFFF2484((_DWORD *)result, (unsigned int *)result, a2, v10);
      if ( (a4 & v13) != 0 )
        sub_FFFF2484((_DWORD *)result, v15, a2, v10);
      v13 >>= 1;
    }
    sub_FFFF2528((_DWORD *)result, a2, v10);
  }
}

//----- (FFFF26EC) --------------------------------------------------------
_DWORD *__fastcall MD5Init(_DWORD *result)
{
  if ( result )
  {
    *result = 0x67452301;
    result[1] = 0xEFCDAB89;
    result[2] = 0x98BADCFE;
    result[3] = 0x10325476;
    result[4] = 0;
  }
  return result;
}

//----- (FFFF2714) --------------------------------------------------------
int __fastcall sub_FFFF2714(int *a1, int *a2)
{
  int v2; // r6
  int v3; // r4
  int v4; // t2
  int v5; // r12
  int v6; // t2
  int v7; // r3
  int v8; // t2
  int v9; // r5
  int v10; // t2
  int v11; // r7
  int v12; // r4
  int v13; // t2
  int v14; // r2
  int v15; // t2
  int v16; // r12
  int v17; // r3
  int v18; // t2
  int v19; // r5
  int v20; // t2
  int v21; // r4
  int v22; // t2
  int v23; // r2
  int v24; // t2
  int v25; // r3
  int v26; // t2
  int v27; // lr
  int v28; // r5
  int v29; // t2
  int v30; // r8
  int v31; // r4
  int v32; // t2
  int v33; // r9
  int v34; // r2
  int v35; // t2
  int v36; // r0
  int v37; // r3
  int v38; // t2
  int v39; // r10
  int v40; // r5
  int v41; // t2
  int v42; // r4
  int v43; // r10
  int v44; // r4
  int v45; // t2
  int v46; // r2
  int v47; // r10
  int v48; // r2
  int v49; // t2
  int v50; // r3
  int v51; // r10
  int v52; // r3
  int v53; // t2
  int v54; // r5
  int v55; // r10
  int v56; // r5
  int v57; // t2
  int v58; // r4
  int v59; // r10
  int v60; // r4
  int v61; // t2
  int v62; // r2
  int v63; // r10
  int v64; // r2
  int v65; // t2
  int v66; // r3
  int v67; // r10
  int v68; // r3
  int v69; // t2
  int v70; // r5
  int v71; // r10
  int v72; // r5
  int v73; // t2
  int v74; // r4
  int v75; // r10
  int v76; // r4
  int v77; // t2
  int v78; // r2
  int v79; // r10
  int v80; // r2
  int v81; // t2
  int v82; // r3
  int v83; // r10
  int v84; // r3
  int v85; // t2
  int v86; // r5
  int v87; // r10
  int v88; // r5
  int v89; // t2
  int v90; // r4
  int v91; // r10
  int v92; // r4
  int v93; // t2
  int v94; // r2
  int v95; // r10
  int v96; // r2
  int v97; // t2
  int v98; // r3
  int v99; // r5
  int v100; // t2
  int v101; // r4
  int v102; // t2
  int v103; // r2
  int v104; // t2
  int v105; // r3
  int v106; // t2
  int v107; // r5
  int v108; // t2
  int v109; // r4
  int v110; // t2
  int v111; // r2
  int v112; // t2
  int v113; // r3
  int v114; // t2
  int v115; // r5
  int v116; // t2
  int v117; // r4
  int v118; // t2
  int v119; // r2
  int v120; // t2
  int v121; // r3
  int v122; // t2
  int v123; // r5
  int v124; // t2
  int v125; // r4
  int v126; // t2
  int v127; // r2
  int v128; // t2
  int v129; // r3
  int v130; // t2
  int v131; // r5
  int v132; // t2
  int v133; // r4
  int v134; // t2
  int v135; // r2
  int v136; // t2
  int v137; // r3
  int v138; // t2
  int v139; // r5
  int v140; // t2
  int v141; // r4
  int v142; // t2
  int v143; // r2
  int v144; // t2
  int v145; // r3
  int v146; // t2
  int v147; // r5
  int v148; // t2
  int v149; // r4
  int v150; // t2
  int v151; // r2
  int v152; // t2
  int v153; // r3
  int v154; // t2
  int v155; // r0
  int v156; // t2
  int v157; // r4
  int v158; // t2
  int v159; // r2
  int v160; // t2
  int v161; // t2
  int v162; // r5
  int result; // r0
  int v164; // [sp+14h] [bp-70h]
  int v165; // [sp+18h] [bp-6Ch]
  int v166; // [sp+1Ch] [bp-68h]
  int v167; // [sp+24h] [bp-60h]
  int v168; // [sp+28h] [bp-5Ch]
  int v169; // [sp+2Ch] [bp-58h]
  int v170; // [sp+30h] [bp-54h]
  int v171; // [sp+38h] [bp-4Ch]
  int v172; // [sp+40h] [bp-44h]
  int v173; // [sp+44h] [bp-40h]
  int v174; // [sp+48h] [bp-3Ch]
  int v175; // [sp+4Ch] [bp-38h]

  v164 = a2[1];
  v165 = a2[2];
  v166 = a2[3];
  v2 = *a1;
  v167 = a1[1];
  v4 = __ROR4__(*a2 + (v164 & v165 | v166 & ~v164) + *a1 - 680876936, 25);
  v3 = v164 + v4;
  v6 = __ROR4__(v166 + ((v164 + v4) & v164 | v165 & ~(v164 + v4)) + v167 - 389564586, 20);
  v5 = v3 + v6;
  v168 = a1[2];
  v169 = a1[3];
  v8 = __ROR4__(v165 + v168 + ((v3 + v6) & v3 | v164 & ~(v3 + v6)) + 606105819, 15);
  v7 = v5 + v8;
  v10 = __ROR4__(v164 + v169 + ((v5 + v8) & v5 | v3 & ~(v5 + v8)) - 1044525330, 10);
  v9 = v7 + v10;
  v170 = a1[4];
  v11 = a1[5];
  v171 = a1[6];
  v13 = __ROR4__(v170 + ((v7 + v10) & v7 | v5 & ~(v7 + v10)) + v3 - 176418897, 25);
  v12 = v9 + v13;
  v15 = __ROR4__(v5 + ((v9 + v13) & v9 | v7 & ~(v9 + v13)) + v11 + 1200080426, 20);
  v14 = v12 + v15;
  v16 = a1[7];
  v18 = __ROR4__(v7 + ((v12 + v15) & v12 | v9 & ~(v12 + v15)) + v171 - 1473231341, 15);
  v17 = v14 + v18;
  v172 = a1[8];
  v20 = __ROR4__(v9 + ((v14 + v18) & v14 | v12 & ~(v14 + v18)) + v16 - 45705983, 10);
  v19 = v17 + v20;
  v173 = a1[9];
  v22 = __ROR4__(v12 + v172 + ((v17 + v20) & v17 | v14 & ~(v17 + v20)) + 1770035416, 25);
  v21 = v19 + v22;
  v174 = a1[10];
  v24 = __ROR4__(v14 + v173 + ((v19 + v22) & v19 | v17 & ~(v19 + v22)) - 1958414417, 20);
  v23 = v21 + v24;
  v175 = a1[11];
  v26 = __ROR4__(v17 + ((v21 + v24) & v21 | v19 & ~(v21 + v24)) + v174 - 42063, 15);
  v25 = v23 + v26;
  v27 = a1[12];
  v29 = __ROR4__(v19 + ((v23 + v26) & v23 | v21 & ~(v23 + v26)) + v175 - 1990404162, 10);
  v28 = v25 + v29;
  v30 = a1[13];
  v32 = __ROR4__(v21 + ((v25 + v29) & v25 | v23 & ~(v25 + v29)) + v27 + 1804603682, 25);
  v31 = v28 + v32;
  v33 = a1[14];
  v35 = __ROR4__(v23 + ((v28 + v32) & v28 | v25 & ~(v28 + v32)) + v30 - 40341101, 20);
  v34 = v31 + v35;
  v36 = a1[15];
  v38 = __ROR4__(v25 + ((v31 + v35) & v31 | v28 & ~(v31 + v35)) + v33 - 1502002290, 15);
  v37 = v34 + v38;
  v39 = (v34 + v38) & ~v34;
  v41 = __ROR4__(v28 + ((v34 + v38) & v34 | v31 & ~(v34 + v38)) + v36 + 1236535329, 10);
  v40 = v37 + v41;
  v42 = v31 + v167 + ((v37 + v41) & v34 | v39) - 165796510;
  v43 = (v37 + v41) & ~v37;
  v45 = __ROR4__(v42, 27);
  v44 = v40 + v45;
  v46 = v34 + v171 + ((v40 + v45) & v37 | v43) - 1069501632;
  v47 = (v40 + v45) & ~v40;
  v49 = __ROR4__(v46, 23);
  v48 = v44 + v49;
  v50 = v37 + v175 + ((v44 + v49) & v40 | v47) + 643717713;
  v51 = (v44 + v49) & ~v44;
  v53 = __ROR4__(v50, 18);
  v52 = v48 + v53;
  v54 = v40 + (v51 | (v48 + v53) & v44) + v2 - 373897302;
  v55 = (v48 + v53) & ~v48;
  v57 = __ROR4__(v54, 12);
  v56 = v52 + v57;
  v58 = v44 + (v55 | (v52 + v57) & v48) + v11 - 701558691;
  v59 = (v52 + v57) & ~v52;
  v61 = __ROR4__(v58, 27);
  v60 = v56 + v61;
  v62 = v48 + v174 + ((v56 + v61) & v52 | v59) + 38016083;
  v63 = (v56 + v61) & ~v56;
  v65 = __ROR4__(v62, 23);
  v64 = v60 + v65;
  v66 = v52 + (v63 | (v60 + v65) & v56) + v36 - 660478335;
  v67 = (v60 + v65) & ~v60;
  v69 = __ROR4__(v66, 18);
  v68 = v64 + v69;
  v70 = v56 + v170 + ((v64 + v69) & v60 | v67) - 405537848;
  v71 = (v64 + v69) & ~v64;
  v73 = __ROR4__(v70, 12);
  v72 = v68 + v73;
  v74 = v60 + v173 + ((v68 + v73) & v64 | v71) + 568446438;
  v75 = (v68 + v73) & ~v68;
  v77 = __ROR4__(v74, 27);
  v76 = v72 + v77;
  v78 = v64 + (v75 | (v72 + v77) & v68) + v33 - 1019803690;
  v79 = (v72 + v77) & ~v72;
  v81 = __ROR4__(v78, 23);
  v80 = v76 + v81;
  v82 = v68 + v169 + ((v76 + v81) & v72 | v79) - 187363961;
  v83 = (v76 + v81) & ~v76;
  v85 = __ROR4__(v82, 18);
  v84 = v80 + v85;
  v86 = v72 + v172 + ((v80 + v85) & v76 | v83) + 1163531501;
  v87 = (v80 + v85) & ~v80;
  v89 = __ROR4__(v86, 12);
  v88 = v84 + v89;
  v90 = v76 + (v87 | (v84 + v89) & v80) + v30 - 1444681467;
  v91 = (v84 + v89) & ~v84;
  v93 = __ROR4__(v90, 27);
  v92 = v88 + v93;
  v94 = v80 + v168 + ((v88 + v93) & v84 | v91) - 51403784;
  v95 = (v88 + v93) & ~v88;
  v97 = __ROR4__(v94, 23);
  v96 = v92 + v97;
  v98 = v92 + v97 + __ROR4__(v84 + (v95 | (v92 + v97) & v88) + v16 + 1735328473, 18);
  v100 = __ROR4__(v88 + ((v92 + v97) & ~v92 | v98 & v92) + v27 - 1926607734, 12);
  v99 = v98 + v100;
  v102 = __ROR4__(v92 + ((v98 + v100) ^ v98 ^ v96) + v11 - 378558, 28);
  v101 = v99 + v102;
  v104 = __ROR4__(v96 + v172 + ((v99 + v102) ^ v99 ^ v98) - 2022574463, 21);
  v103 = v101 + v104;
  v106 = __ROR4__(v98 + v175 + ((v101 + v104) ^ v101 ^ v99) + 1839030562, 16);
  v105 = v103 + v106;
  v108 = __ROR4__(v99 + ((v103 + v106) ^ v103 ^ v101) + v33 - 35309556, 9);
  v107 = v105 + v108;
  v110 = __ROR4__(v101 + v167 + ((v105 + v108) ^ v105 ^ v103) - 1530992060, 28);
  v109 = v107 + v110;
  v112 = __ROR4__(v103 + v170 + ((v107 + v110) ^ v107 ^ v105) + 1272893353, 21);
  v111 = v109 + v112;
  v114 = __ROR4__(v105 + ((v109 + v112) ^ v109 ^ v107) + v16 - 155497632, 16);
  v113 = v111 + v114;
  v116 = __ROR4__(v107 + v174 + ((v111 + v114) ^ v111 ^ v109) - 1094730640, 9);
  v115 = v113 + v116;
  v118 = __ROR4__(v109 + ((v113 + v116) ^ v113 ^ v111) + v30 + 681279174, 28);
  v117 = v115 + v118;
  v120 = __ROR4__(v111 + ((v115 + v118) ^ v115 ^ v113) + v2 - 358537222, 21);
  v119 = v117 + v120;
  v122 = __ROR4__(v113 + v169 + ((v117 + v120) ^ v117 ^ v115) - 722521979, 16);
  v121 = v119 + v122;
  v124 = __ROR4__(v115 + v171 + ((v119 + v122) ^ v119 ^ v117) + 76029189, 9);
  v123 = v121 + v124;
  v126 = __ROR4__(v117 + v173 + ((v121 + v124) ^ v121 ^ v119) - 640364487, 28);
  v125 = v123 + v126;
  v128 = __ROR4__(v119 + ((v123 + v126) ^ v123 ^ v121) + v27 - 421815835, 21);
  v127 = v125 + v128;
  v130 = __ROR4__(v121 + ((v125 + v128) ^ v125 ^ v123) + v36 + 530742520, 16);
  v129 = v127 + v130;
  v132 = __ROR4__(v123 + v168 + ((v127 + v130) ^ v127 ^ v125) - 995338651, 9);
  v131 = v129 + v132;
  v134 = __ROR4__(v125 + v2 + ((~v127 | (v129 + v132)) ^ v129) - 198630844, 26);
  v133 = v131 + v134;
  v136 = __ROR4__(v127 + v16 + ((~v129 | (v131 + v134)) ^ v131) + 1126891415, 22);
  v135 = v133 + v136;
  v138 = __ROR4__(v129 + ((~v131 | (v133 + v136)) ^ v133) + v33 - 1416354905, 17);
  v137 = v135 + v138;
  v140 = __ROR4__(v131 + ((~v133 | (v135 + v138)) ^ v135) + v11 - 57434055, 11);
  v139 = v137 + v140;
  v142 = __ROR4__(v133 + ((~v135 | (v137 + v140)) ^ v137) + v27 + 1700485571, 26);
  v141 = v139 + v142;
  v144 = __ROR4__(v135 + v169 + ((~v137 | (v139 + v142)) ^ v139) - 1894986606, 22);
  v143 = v141 + v144;
  v146 = __ROR4__(v137 + v174 + ((~v139 | (v141 + v144)) ^ v141) - 1051523, 17);
  v145 = v143 + v146;
  v148 = __ROR4__(v139 + v167 + ((~v141 | (v143 + v146)) ^ v143) - 2054922799, 11);
  v147 = v145 + v148;
  v150 = __ROR4__(v141 + v172 + ((~v143 | (v145 + v148)) ^ v145) + 1873313359, 26);
  v149 = v147 + v150;
  v152 = __ROR4__(v36 + ((~v145 | (v147 + v150)) ^ v147) + v143 - 30611744, 22);
  v151 = v149 + v152;
  v154 = __ROR4__(v171 + ((~v147 | (v149 + v152)) ^ v149) + v145 - 1560198380, 17);
  v153 = v151 + v154;
  v156 = __ROR4__(v147 + ((~v149 | (v151 + v154)) ^ v151) + v30 + 1309151649, 11);
  v155 = v153 + v156;
  v158 = __ROR4__(v170 + ((~v151 | (v153 + v156)) ^ v153) + v149 - 145523070, 26);
  v157 = v155 + v158;
  v160 = __ROR4__(v151 + v175 + ((~v153 | (v155 + v158)) ^ v155) - 1120210379, 22);
  v159 = v157 + v160;
  v161 = __ROR4__(v153 + v168 + ((~v155 | (v157 + v160)) ^ v157) + 718787259, 17);
  v162 = *a2 + v157;
  a2[3] = v159 + v166;
  *a2 = v162;
  a2[2] = v165 + v159 + v161;
  result = v159 + v161 + __ROR4__(v173 + ((~v157 | (v159 + v161)) ^ v159) + v155 - 343485551, 11) + v164;
  a2[1] = result;
  return result;
}

//----- (FFFF3108) --------------------------------------------------------
int __fastcall sub_FFFF3108(int result, int a2, int *a3)
{
  int *v3; // r6
  int v5; // r4

  v3 = (int *)result;
  if ( (a2 & 0xF) == 0 )
  {
    v5 = a2;
    result = a3[4] + a2;
    for ( a3[4] = result; v5; v3 += 16 )
    {
      result = sub_FFFF2714(v3, a3);
      v5 -= 16;
    }
  }
  return result;
}

//----- (FFFF314C) --------------------------------------------------------
int __fastcall MD5Final(int *a1, unsigned int a2, int *a3)
{
  int *v3; // r6
  unsigned int v4; // r4
  unsigned int v6; // r8
  unsigned int v7; // r0
  unsigned int i; // r1
  int v9; // t1
  unsigned int j; // r0
  _DWORD v12[24]; // [sp+0h] [bp-60h] BYREF

  v3 = a1;
  v4 = a2;
  v6 = a3[4] + a2;
  if ( a2 >= 0x10 )
  {
    sub_FFFF3108((int)a1, a2 & 0xFFFFFFF0, a3);
    v7 = v4 & 0xFFFFFFF0;
    v4 &= 0xFu;
    v3 += v7;
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( i >= v4 )
    {
      v12[i] = 0;
    }
    else
    {
      v9 = *v3++;
      v12[i] = v9;
    }
  }
  v12[v4] = 128;
  if ( v4 >= 0xE )
  {
    sub_FFFF3108((int)v12, 16, a3);
    for ( j = 0; j < 0x10; ++j )
      v12[j] = 0;
  }
  v12[14] = 32 * v6;
  return sub_FFFF3108((int)v12, 16, a3);
}

//----- (FFFF3204) --------------------------------------------------------
int efuse_get_timer_tick()
{
  return MEMORY[0x87003004];
}

//----- (FFFF3210) --------------------------------------------------------
int efuse_parameter_config_1()
{
  unsigned int v0; // r1
  int timer_tick; // r5
  int result; // r0

  v0 = 0;
  MEMORY[0x8B000008] |= 0x80u;
  MEMORY[0x8B00004C] |= 0x10000000u;
  do
    ++v0;
  while ( v0 < 0x64 );
  MEMORY[0x8B00004C] &= ~0x10000000u;
  MEMORY[0x89000010] |= 0x20000000u;
  timer_tick = efuse_get_timer_tick();
  result = efuse_get_timer_tick();
  MEMORY[0x89000010] |= 0x10000000u;
  MEMORY[0x89000010] |= 0x80000000;
  while ( result == timer_tick )
    result = efuse_get_timer_tick();
  return result;
}

//----- (FFFF3268) --------------------------------------------------------
unsigned int efuse_parameter_config_2()
{
  unsigned int result; // r0

  MEMORY[0x89000010] &= ~0x10000000u;
  MEMORY[0x89000010] &= ~0x80000000;
  MEMORY[0x89000010] &= ~0x20000000u;
  result = MEMORY[0x8B000008] & 0xFFFFFF7F;
  MEMORY[0x8B000008] &= ~0x80u;
  return result;
}

//----- (FFFF3292) --------------------------------------------------------
signed int __fastcall efuse_read(unsigned int a1, _DWORD *a2)
{
  int v3; // r6
  int v5; // r5
  int timer_tick; // r7

  v3 = 0;
  if ( a1 >= 9 )
    return 6;
  MEMORY[0x89000008] = a1 | (a1 << 16);
  MEMORY[0x8900000C] |= 2u;                     // EFUSE_RD_START, start reading efuse
  v5 = MEMORY[0x89000014] & 2;
  timer_tick = efuse_get_timer_tick();
  do
  {
    if ( v5 != 2 )
      goto LABEL_8;
    v5 = MEMORY[0x89000014] & 2;
  }
  while ( (unsigned int)(efuse_get_timer_tick() - timer_tick) <= 2 );
  if ( v5 != 2 )
  {
LABEL_8:
    *a2 = MEMORY[0x89000000];
    return v3;
  }
  return 1;
}

//----- (FFFF32EE) --------------------------------------------------------
signed int __fastcall sub_FFFF32EE(unsigned int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-8h] BYREF

  v5 = a4;
  if ( efuse_read(a1, &v5) )
    return 1;
  if ( v5 >= 0 )
    return 13;
  return 14;
}

//----- (FFFF330A) --------------------------------------------------------
int __fastcall efuse_program_related(unsigned int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r6
  int timer_tick; // r8
  int v9; // r6
  int v10; // [sp+0h] [bp-20h] BYREF

  v10 = a4;
  if ( a1 >= 9 )
    return 6;
  result = sub_FFFF32EE(a1, a2, a3, a4);
  if ( result != 14 )
  {
    MEMORY[0x89000020] = 0x8810;                // EFUSE_MAGIC_NUMBER = 0x8810 , permitting efuse programming
    MEMORY[0x89000008] = a1 | (a1 << 16);
    MEMORY[0x89000004] = a2;
    MEMORY[0x89000010] |= 0x10000 << a1;
    MEMORY[0x8900000C] |= 1u;
    v7 = MEMORY[0x89000014] & 1;
    timer_tick = efuse_get_timer_tick();
    while ( v7 == 1 )
    {
      v7 = MEMORY[0x89000014] & 1;
      if ( (unsigned int)(efuse_get_timer_tick() - timer_tick) > 3 )
      {
        if ( v7 == 1 )
        {
          MEMORY[0x89000020] = 0;
          return 2;
        }
        break;
      }
    }
    v9 = MEMORY[0x89000018] & (256 << a1);
    if ( efuse_read(a1, &v10) )
    {
      result = 4;
    }
    else if ( (a2 & 0x7FFFFFFF) == (v10 & 0x7FFFFFFF) )
    {
      if ( v9 )
        result = 9;
      else
        result = 0;
    }
    else if ( v9 )
    {
      result = 10;
    }
    else
    {
      result = 3;
    }
    MEMORY[0x89000020] = 0;
  }
  return result;
}

//----- (FFFF33BE) --------------------------------------------------------
signed int __fastcall sub_FFFF33BE(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // r0
  int v6; // r2
  int v7; // r3
  int v8; // [sp+0h] [bp-10h] BYREF

  v8 = a4;
  result = efuse_read(a1, &v8);
  if ( !result )
  {
    if ( v8 >= 0 )
      return efuse_program_related(a1, v8 | 0x80000000, v6, v7);
    else
      return 0;
  }
  return result;
}
// FFFF33DE: variable 'v6' is possibly undefined
// FFFF33DE: variable 'v7' is possibly undefined

//----- (FFFF33E4) --------------------------------------------------------
signed int __fastcall sub_FFFF33E4(int a1, int a2, int a3, int a4)
{
  unsigned int i; // r4
  signed int result; // r0

  for ( i = 1; i <= 4; ++i )
  {
    result = sub_FFFF33BE(i, a2, a3, a4);
    if ( result )
      break;
  }
  return result;
}
// FFFF33EA: variable 'a2' is possibly undefined
// FFFF33EA: variable 'a3' is possibly undefined
// FFFF33EA: variable 'a4' is possibly undefined

//----- (FFFF33FA) --------------------------------------------------------
int __fastcall sub_FFFF33FA(_DWORD *a1)
{
  unsigned int i; // r4
  int result; // r0

  for ( i = 1; i <= 4; ++i )
  {
    result = efuse_read(i, a1);
    if ( result )
      break;
    ++a1;
  }
  return result;
}

//----- (FFFF3416) --------------------------------------------------------
int __fastcall sub_FFFF3416(_DWORD *a1, int a2, int a3, int a4)
{
  unsigned int i; // r4
  int result; // r0

  for ( i = 1; i <= 4; ++i )
  {
    result = efuse_program_related(i, *a1 & 0x7FFFFFFF, a3, a4);
    if ( result )
      break;
    ++a1;
  }
  return result;
}
// FFFF3424: variable 'a3' is possibly undefined
// FFFF3424: variable 'a4' is possibly undefined

//----- (FFFF3436) --------------------------------------------------------
signed int __fastcall sub_FFFF3436(unsigned int a1, bool *a2)
{
  signed int result; // r0
  unsigned int v4; // [sp+0h] [bp-10h] BYREF

  v4 = 0;
  result = efuse_read(a1, &v4);
  if ( !result )
    *a2 = v4 >> 31 == 1;
  return result;
}

//----- (FFFF3460) --------------------------------------------------------
int __fastcall sub_FFFF3460(int *a1, int *a2)
{
  int v2; // r4
  int v7; // r2
  int v8; // r5
  int v9; // r7
  int v10; // r9
  int v11; // r3
  int v12; // r6
  int v13; // r8
  int v14; // r12
  int *v15; // r0
  int v16; // r2
  _BOOL1 v17; // off
  int v18; // r5
  _BOOL1 v19; // off
  int v20; // r7
  _BOOL1 v21; // off
  _BOOL1 v22; // off

  v2 = 8;
  __asm { MSR             CPSR_f, #0x20000000 }
  do
  {
    v7 = *a1;
    v8 = a1[1];
    v9 = a1[2];
    v10 = a1[3];
    v11 = *a2;
    v12 = a2[1];
    v13 = a2[2];
    v14 = a2[3];
    a2 += 4;
    v15 = a1 - 32;
    v17 = _CF;
    _CF = __CFSUB__(v7, v11, _CF);
    v16 = v7 - (v11 + !v17);
    v19 = _CF;
    _CF = __CFSUB__(v8, v12, _CF);
    v18 = v8 - (v12 + !v19);
    v21 = _CF;
    _CF = __CFSUB__(v9, v13, _CF);
    v20 = v9 - (v13 + !v21);
    v22 = _CF;
    _CF = __CFSUB__(v10, v14, _CF);
    *v15 = v16;
    v15[1] = v18;
    v15[2] = v20;
    v15[3] = v10 - (v14 + !v22);
    a1 = v15 + 36;
    --v2;
  }
  while ( v2 );
  return *a1 - !_CF;
}

//----- (FFFF34A8) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF34A8(_DWORD *result, unsigned int *a2, unsigned int a3)
{
  int v3; // r5
  int v4; // r12
  _DWORD *v6; // r4
  unsigned int v11; // t1
  int v12; // r11
  unsigned __int64 v13; // r6
  int v14; // r9
  int v15; // r11
  int v16; // off
  int v17; // off

  v3 = 16;
  v4 = 2;
  v6 = result;
  __asm { MSR             CPSR_f, #0 }
  do
  {
    do
    {
      v11 = *a2;
      a2 += 2;
      v12 = v6[1];
      v13 = a3 * (unsigned __int64)v11;
      v14 = v13 + _CF + *v6;
      v16 = __CFADD__(_CF, *v6) | __CFADD__((_DWORD)v13, _CF + *v6);
      _CF = __CFADD__(v16, v12);
      v15 = v16 + v12;
      _CF |= __CFADD__(HIDWORD(v13), v15);
      *v6 = v14;
      v6[1] = HIDWORD(v13) + v15;
      v6 += 2;
      --v3;
    }
    while ( v3 );
    v3 = 16;
    v17 = _CF;
    _CF = __CFADD__(_CF, *v6);
    *v6 += v17;
    v6 -= 31;
    a2 -= 31;
    --v4;
  }
  while ( v4 );
  return result;
}

// nfuncs=155 queued=146 decompiled=146 lumina nreq=0 worse=0 better=0
// ALL OK, 146 function(s) have been successfully decompiled
